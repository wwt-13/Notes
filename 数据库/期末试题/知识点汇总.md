# 数据库设计过程

1. 需求分析阶段：了解分析用户需求，是最耗时的阶段
    - **数据流图**
    - **数据字典**
2. 概念设计阶段：对现实世界的抽象，也就是绘制 `E-R` 图
3. 逻辑设计阶段：将概念结构转化为一般的**关系模型**、**范式分解**(09 年题目中出现)
4. 数据库物理设计阶段
5. 数据库实施阶段

# 数据库三层模式结构

-   外模式：就是用户视图的逻辑表示
-   逻辑模式：数据库的全局逻辑结构
-   内模式：数据库实际存储的物理结构

# 完整性约束

-   静态列级约束：对列的值域约束
    `name varchar(30) not null`
-   静态元组约束：规定元组的各个列之间的约束关系
    `check(num1>num2)`
-   静态关系约束：关系的各个元组之间或若干关系之间存在的各种联系和约束(需要使用*trigger*实现)
-   动态列级约束：修改列定义或列值是应该满足的约束条件(列定义为数据库自动实现、修改列值则用*trigger*实现)
-   动态元组约束：修改元组值，各个字段需要满足的约束条件(通过*trigger*实现)
-   动态关系约束：对关系变化前后状态的限制条件(事务一致性、原子性等约束条件)

# 事务 4 特性

1. 原子性：要么全做，要么全不做
2. 隔离性：并发执行的各个事物之间不能互相干扰
3. 一致性：需要保证数据库的一致性
4. 持久性：事务提交后，它对数据库的影响是永久的

# 并发控制

并发控制可以保证事务的*一致性*和*隔离性*

1. 丢失修改：事物 T1 和 T2 读取同一数据并修改，T1 的提交结果被 T2 覆盖，导致 T1 的**修改被丢失**
2. 不可重复读：事务 T1 读取某一数据后，事务 T2 对其执行更新操作，使 T1 **无法再现前一次读取结果**
3. 读“脏”数据：事务 T1 修改某一数据并写入磁盘，事务 T2 读取同一数据后，T1 由于某种原因被撤销，此时 T1 修改过的数据恢复原值，T2 读到的数据就与数据库中的数据不一致

-   一级封锁协议：视图 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放
    只能防止丢失修改，并且因为读数据不需要加锁，所以无法防止不可重复读和脏读
-   二级封锁协议：在一级封锁协议的基础上，要求事务 T 在读取数据 R 前必须先加 S 锁，读完后即可释放 S 锁
    可以防止丢失修改和脏读(因为 T2 读数据需要申请 S 锁，但是 T1 已经申请了 X 锁，T2 只有等 T1 结束才能读取数据，从而避免了脏读)
-   三级封锁协议：在二级封锁协议的基础上，要求事务 T 加的 S 锁等到事务结束再释放(可以防止丢失修改、脏读和不可重复读)

两段锁协议(2PL)：若并行执行的所有事务均遵守两段锁协议，则对这些事务的所有并行调度策略都是*可串行化的*

1. 在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁
2. 在释放一个封锁之后，事务不再获得任何其他锁

严格的两段锁协议：在两段锁协议的基础上，增加规则(**事务获得的锁只有在事务结束时才能释放**)

# 数据库理论

-   1NF: 关系中的每个属性均不可再分
-   2NF: 在 1NF 的基础上，要求每个非主属性都完全函数依赖于 R 的每个关系键
-   3NF: 在 2NF 的基础上，要求每个非主属性都不传递依赖于 R 的每个关系键
-   BCNF: 在 3NF 的基础上，消除了主属性之间的部分函数依赖和传递函数依赖

# 最小依赖集

1. 将 F 的所有函数依赖的右边化为单一属性
2. 去掉 F 中的所有函数依赖左边的冗余*属性*(只针对 F 中做不不是单一属性的函数依赖)
3. 去掉 F 中的所有冗余的**函数依赖**

举例

R<U,F>,U={A,B,C,D},F={A->BD,AB->C,C->D}

1. F={A->B,A->D,AB->C,C->D}
2. 因为只有 AB->C 左部不单一
    - 先看 A 是不是冗余属性，$B_F^{+}={B}$，无法推出 A，所以 B 不是冗余属性
    - 再看 B 是不是冗余属性，$A_F^{+}={A,B,D,C}$，可以推出 B，所以 B 是冗余属性，去掉 B
      F={A->B,A->D,A->C,C->D}
3. 去掉 F 中冗余的函数依赖
    - A->B，先从 F 中去掉 A->B，则 F={A->D,A->C,C->D}，查看$A_F^{+}={A,D,C}$，无法推出 B，所以 A->B 不冗余，需要保留
    - 依次类推，可以发现 A->D 为冗余函数依赖，需要去除，最终得到最小依赖集为 F={A->B,A->C,C->D}

# 无损连接性分解判断

> 无损连接性保证了不会丢失信息

1. 建立一张 n 列 k 行的表，每一列对应一个属性，每一行对应分解中的一个关系模式，若属性 Aj 属于 Ui，则在 j 列 i 行上填 aj，否则填 bij
2. 对于每个 FDi 做如下操作，找到 Xi 所对应的列中具有相同符号的那些行。考察这些行中 li 列的元素，若其中有 aj，则全部改为 aj，否则全部改为 bmli，m 是这些行的行号最小值。

举例

R<U,F>,U={A,B,C,D,E},F={A->C,B->C,C->D,DE->C,CE->A}

R 的一个分解为 R1(AD),R2(AB),R3(BE),R4(CDE),R5(AE)

| R       | A   | B   | C   | D   | E   |
| ------- | --- | --- | --- | --- | --- |
| R1(AD)  | a1  | b12 | b13 | a4  | b15 |
| R2(AB)  | a1  | a2  | b23 | b24 | b25 |
| R3(BE)  | b21 | a2  | b23 | b24 | a5  |
| R4(CDE) | b31 | b32 | a3  | a4  | a5  |
| R5(AE)  | a1  | b42 | b43 | b44 | a5  |

A->C

| R       | A    | B   | C       | D   | E   |
| ------- | ---- | --- | ------- | --- | --- |
| R1(AD)  | _a1_ | b12 | **b13** | a4  | b15 |
| R2(AB)  | _a1_ | a2  | b23     | b24 | b25 |
| R3(BE)  | b21  | a2  | **b13** | b24 | a5  |
| R4(CDE) | b31  | b32 | a3      | a4  | a5  |
| R5(AE)  | _a1_ | b42 | **b13** | b44 | a5  |

B->C

| R       | A   | B    | C       | D   | E   |
| ------- | --- | ---- | ------- | --- | --- |
| R1(AD)  | a1  | b12  | b13     | a4  | b15 |
| R2(AB)  | a1  | _a2_ | **b13** | b24 | b25 |
| R3(BE)  | b21 | _a2_ | **b13** | b24 | a5  |
| R4(CDE) | b31 | b32  | a3      | a4  | a5  |
| R5(AE)  | a1  | b42  | b13     | b44 | a5  |

C->D

| R       | A   | B   | C     | D      | E   |
| ------- | --- | --- | ----- | ------ | --- |
| R1(AD)  | a1  | b12 | _b13_ | **a4** | b15 |
| R2(AB)  | a1  | a2  | _b13_ | **a4** | b25 |
| R3(BE)  | b21 | a2  | _b13_ | **a4** | a5  |
| R4(CDE) | b31 | b32 | a3    | a4     | a5  |
| R5(AE)  | a1  | b42 | _b13_ | **a4** | a5  |

DE->C

| R       | A   | B   | C      | D    | E    |
| ------- | --- | --- | ------ | ---- | ---- |
| R1(AD)  | a1  | b12 | b13    | a4   | b15  |
| R2(AB)  | a1  | a2  | b13    | a4   | b25  |
| R3(BE)  | b21 | a2  | **a3** | _a4_ | _a5_ |
| R4(CDE) | b31 | b32 | **a3** | _a4_ | _a5_ |
| R5(AE)  | a1  | b42 | **a3** | _a4_ | _a5_ |

CE->A

| R       | A      | B   | C    | D   | E    |
| ------- | ------ | --- | ---- | --- | ---- |
| R1(AD)  | a1     | b12 | b13  | a4  | b15  |
| R2(AB)  | a1     | a2  | b13  | a4  | b25  |
| R3(BE)  | **a1** | a2  | _a3_ | a4  | _a5_ |
| R4(CDE) | **a1** | b32 | _a3_ | a4  | _a5_ |
| R5(AE)  | **a1** | b42 | _a3_ | a4  | _a5_ |

此时发现 R3(BE)为 a1->a2->a3->a4->a5，说明该分解具有无损连接性

# 分解的函数依赖保持性判断

> 可以解决异常情况

对于关系模式 R<U,F>,设 P={R1(U1,F1),R2(U2,F2),...Rn(Un,Fn)}是 R 的一个分解，若 F 的闭包 F+=(Fi 交集)的闭包，则称分解 P 保持函数依赖

例题

R={A,B,C,D,E},F={B->A,D->A,A->E,AC->B},判断分解 P={R1(ABCE),R2(CD)}是否保持函数依赖？

已知分解，则可知 R1、R2 的函数依赖为(注意需要算上传递依赖)

-   $B_F^{+}={B,A,E}$
-   $D_F^{+}={D,A,E}$
-   $A_F^{+}={A,E}$
-   ${AC}_F^{+}={A,C,B,E}$

由上可得

F1={B->A,A->E,AC->B,B->E,AC->E}
F2={null}(因为 D 的闭包没有 C，并且 C 的闭包是空集)

接下来求 UFi 即可

F={_B->A_,D->A,_A->E_,_AC->B_}
G=UFi={_B->A_,_A->E_,_AC->B_,B->E,AC->E}

所以只要判断$D_G^{+}$内是否存在 A 即可，显然不存在，所以该分解不能保持函数依赖
