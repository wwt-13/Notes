## 课本第130页第5题 1~7小题

![[CleanShot 2023-03-22 at 15.50.12.png|800]]
建表指令👇🏻

```sql
create table if not exists S(
	Sno varchar(10),
	Sname varchar(10),
	Status int,
	city varchar(10),
	primary key(Sno)
);
create table if not exists P(
	Pno varchar(10),
	Pname varchar(10),
	color varchar(10),
	weight int,
	primary key(Pno)
);
create table if not exists J(
	Jno varchar(10),
	Jname varchar(10),
	city varchar(10),
	primary key(Jno)
);
create table if not exists SPJ(
	Sno varchar(10),
	Pno varchar(10),
	Jno varchar(10),
	Qty int,
	foreign key(Sno) references S(Sno),
	foreign key(Pno) references P(Pno),
	foreign key(Jno) references J(Jno)
);
```

数据插入

```sql
insert into S(Sno,Sname,Status,city)
values
('S1','精益',20,'天津'),
('S2','盛锡',10,'北京'),
('S3','东方红',30,'北京'),
('S4','丰泰盛',20,'天津'),
('S5','为民',30,'上海');
insert into P(Pno,Pname,color,weight)
values
('P1','螺母','红',12),
('P2','螺栓','绿',17),
('P3','螺丝刀','蓝',14),
('P4','螺丝刀','红',14),
('P5','凸轮','蓝',40),
('P6','齿轮','红',30);
insert into J(Jno,Jname,city)
values
('J1','三建','北京'),
('J2','一汽','长春'),
('J3','弹簧厂','天津'),
('J4','造船厂','天津'),
('J5','机车厂','唐山'),
('J6','无线电厂','常州'),
('J7','半导体厂','南京');
insert into SPJ(Sno,Pno,Jno,Qty)
values
('S1','P1','J1',200),
('S1','P1','J3',100),
('S1','P1','J4',700),
('S1','P2','J2',100),
('S2','P3','J1',400),
('S2','P3','J2',200),
('S2','P3','J4',500),
('S2','P3','J5',400),
('S2','P5','J1',400),
('S2','P5','J2',100),
('S3','P1','J1',200),
('S3','P3','J1',200),
('S4','P5','J1',100),
('S4','P6','J3',300),
('S4','P6','J4',200),
('S5','P2','J4',100),
('S5','P3','J1',200),
('S5','P6','J2',200),
('S5','P6','J4',500);
```

建表和数据均插入成功👇🏻
![[CleanShot 2023-03-22 at 16.37.49.png]]
![[CleanShot 2023-03-22 at 16.37.39.png]]

1. 找出所有供应商的姓名和所在城市
   ```sql
   select Sname,city
   from S;
   ```
2. 找出所有零件的名称、颜色、重量
   ```sql
   select Pname,coloc,weight
   from P;
   ```
3. 找出使用供应商S1所供应零件的工程号码
   ```sql
   select Pno
   from P 
   where Pno in(
       select Pno from SPJ where Sno='S1'
   );
   ```
4. 找出工程项目J2使用的各种零件的名称及其数量
   ```sql
   select Pname,sum(Qty)
   from SPJ natural join J
   group by Pname; 
   ```
5. 找出上海厂商供应的所有零件号码
   ```sql
   select distinct Pno 
   from SPJ natural join S
   where city='上海';
   ```
6. 找出使用上海产的零件的工程号码
   ```sql
   select distinct Jno
   from SPJ natural join S
   where city='上海';
   ```
7. 找出没有使用天津产的零件的工程号码
   ```sql
   select T1.Jno
   from (
       select distinct Jno
       from SPJ natural join S
   )T1 left join(
       select distinct Jno
       from SPJ natural join S
       where city='天津' 
   )T2 on T1.Jno=T2.Jno
   where T2.Jno is NULL;
   ```

使用到的数据库脚本👇🏻
![[create.sql]]

![[insert.sql]]

## SQL练习

### 学生选课1

> 关系模式简化如下：
> Stu(Sno,Sname,Sage,Sex)
> C(Cno,Cname,Tname)
> SC(Cno,Sno,Grade)

建表脚本+数据插入👇🏻

> [!hint]
> 此数据为chat-gpt3.5-local随机生成

```sql
create table Stu(
	Sno int auto_increment,
	Sname char(20),
	Sage int default(18),
	Ssex enum('male','female'),
	primary key(Sno)
);
create table C(
	Cno int auto_increment,
	Cname char(20),
	Tname char(20),
	primary key(Cno)
);
create table SC(
	Cno int,
	Sno int,
	Grade int,
	foreign key(Cno) references C(Cno),
	foreign key(Sno) references Stu(Sno)
);
insert into Stu (Sname, Sage, Sex)
values
    ('John', 20, 'M'),
    ('Jane', 22, 'F'),
    ('Bob', 19, 'M'),
    ('Alice', 21, 'F'),
    ('Tom', 20, 'M'),
    ('Mary', 23, 'F'),
    ('David', 22, 'M'),
    ('Susan', 20, 'F'),
    ('Mike', 21, 'M'),
    ('Emily', 19, 'F');

insert into C (Cname, Tname)
values
    ('Math', 'Johnson'),
    ('English', 'Smith'),
    ('History', 'Brown'),
    ('Chemistry', 'Wilson'),
    ('Physics', 'Davis'),
    ('Biology', 'Miller'),
    ('Art', 'Taylor'),
    ('Music', 'Anderson'),
    ('Physical Education', 'Thomas'),
    ('Computer Science', 'Clark');

insert into SC (Sno, Cno, Grade)
values
    (1, 1, 90),
    (1, 2, 85),
    (2, 3, 92),
    (2, 4, 88),
    (3, 5, 80),
    (3, 6, 75),
    (4, 7, 95),
    (4, 8, 90),
    (5, 9, 85),
    (5, 10, 80),
    (6, 1, 92),
    (6, 3, 90),
    (7, 5, 87),
    (7, 7, 95),
    (8, 9, 80),
    (8, 10, 85),
    (9, 2, 90),
    (9, 4, 92),
    (10, 6, 85),
    (10, 8, 90);
# 因为后面要查询选修所有课的Sno
insert into SC(Sno,Cno,Grade)
values
	(1,3,40),
	(1,4,50),
	(1,5,60),
	(1,6,90),
	(1,7,20),
	(1,8,100),
	(1,9,60),
	(1,10,70);
```

![[CleanShot 2023-03-25 at 16.13.17.png]]

1. 检索年龄大于 20 岁的男生的学号和姓名
   ```sql
   select Sno,Sname
   from Stu
   where Sage>20 and Ssex='M';
   ```
2. 检索选修了姓刘的老师所教授的课程的女学生的姓名
   ```sql
   select Sname
   from Stu natural join SC natural join C
   where Ssex='F' and Tname like '刘%';
   ```
3. 检索李想同学不学的课程的课程号和课程名
   ```sql
   # not in做法
   select distinct Cno,Cname
   from Stu natural join SC natural join C
   where Cno not in(
       select Cno 
       from Stu natural join SC
       where Sname='刘想'
   );
   # left join做法(还是把问题想复杂了)
   select T1.Cno,T1.Cname
   from (
       select distinct Cno,Cname
       from Stu natural join SC natural join C  
   ) T1 left join (
       select distinct Cno,Cname
       from Stu natural join SC natural join C
       where Sname='刘想'
   ) T2 on T1.Cno=T2.Cno
   where T2.Cno is NULL;
   ```
4. 检索至少选修了两门课程的学生的学号
   ```sql
   select distinct SC.Sno
   from SC join SC as a
   on SC.Sno=a.Sno
   where SC.Cno!=a.Cno;
   ```
5. 求刘老师所教授课程的每门课的平均成绩
   ```sql
   select Cno,avg(Grade)
   from C natural join SC
   where Tname like '刘%'
   group by Cno;
   ```
6. 假设不存在重修的情况，请统计每门课的选修人数(选课人数超过两人的课程才统计)。 要求显示课程号和人数，查询结果按人数降序排列，若人数相同，按课程号升序排列
   ```sql
   select Cno,count(*)
   from SC
   group by Cno
   having count(*)>=2 # 因为选课人数均为2人所以不用>了先
   order by count(*) desc,Cno asc;
   ```
7. 求年龄大于所有女生年龄的男生的姓名和年龄
   ```sql
   select Sname,Sage
   from Stu
   where Ssex='M' and Sage>all(
       select Sage
       from Stu
       where Ssex='F'
   );
   ```
8. 假定不存在重修的情况，求选修了所有课程的学生的学号姓名。(可以不用相关子查询做)
   ```sql
   # 不使用相关子查询
   select Sno,count(*)
   from SC
   group by Sno
   having count(*)=(
       select count(*)
       from C
   );
   # 使用相关子查询
   # 不存在这样的课程，学生x没有选修
   select Sno,Sname
   from Stu
   # 此内层是所有x所在的表
   where not exists(
       select *
       from C
       # 最内层是x关系所在的表
       where not exists(
    	   select *
    	   from SC
    	   where SC.Cno=C.Cno and SC.Sno=Stu.Sno
       )
   );
   ```
9. 查询重修次数在 2 次以上的学生学号，课程号，重修次数
   ```sql
   select *
   from (
       select Sno,count(*)
       from SC
       where Grade<=60
       group by Sno
       having count(*)>2  
   )T1 join (
       select Cno
       from SC
       where Grade<=60
   )T2;
   ```
10. 查询重修学生人数最多的课程号，课程名，教师姓名
    ```sql
    select Cno,Cname,Tname from
    (
        select Cno,count(*)
        from SC
        where Grade<=60
        group by Cno
        having count(*)=(
     	   select count(*)
     	   from SC
     	   where Grade<=60
     	   group by Cno
     	   order by count(*)
     	   LIMIT 1
        )
    )T natural join C;
    ```

> [!warning] 出现的问题总结
>
> 1. 使用on的话必须显式指定join语句
> 2. 表重命名用as
> 3. is NULL而不是=NULL
> 4. Like语句不要和=弄混
> 5. 反向查询使用not in(left join也正确但是太复杂了)
> 6. 注意distinct的使用
> 7. 多表查询，注意select中列名需要改为"表.列名"
> 8. where语句和group by语句的执行顺序问题
> 9. 多重排序顺序的指定规范
> 10. 如何为多表连接后的结果表指定别名

### 学生选课2

> 关系模式简化如下：
> Stu(Sno,Sname,Sage,Sex,Sclass)
> C(Cno,Cname,Cpreno,Credit)
> SC(Sno,Cno,Tno,Grade)
> T(Tno,Tname)

创建列表并插入数据👇🏻

```sql
-- Create the Stu table
CREATE TABLE Stu (
  Sno INT AUTO_INCREMENT PRIMARY KEY,
  Sname VARCHAR(50) NOT NULL,
  Sage INT NOT NULL,
  Sex VARCHAR(10) NOT NULL,
  Sclass VARCHAR(50) NOT NULL
);

-- Create the C table
CREATE TABLE C (
  Cno INT NOT NULL,
  Cname VARCHAR(50) NOT NULL,
  Cpreno INT,
  Credit INT NOT NULL,
  PRIMARY KEY (Cno)
);
-- Create the T table
CREATE TABLE T (
  Tno INT AUTO_INCREMENT PRIMARY KEY,
  Tname VARCHAR(50) NOT NULL
);

-- Create the SC table
CREATE TABLE SC (
  Sno INT NOT NULL,
  Cno INT NOT NULL,
  Tno INT NOT NULL,
  Grade INT NOT NULL,
  PRIMARY KEY (Sno, Cno, Tno),
  FOREIGN KEY (Sno) REFERENCES Stu(Sno),
  FOREIGN KEY (Cno) REFERENCES C(Cno),
  FOREIGN KEY (Tno) REFERENCES T(Tno)
);

-- Insert data into the Stu table
INSERT INTO Stu (Sname, Sage, Sex, Sclass) VALUES
  ('John', 20, 'M', 'Class A'),
  ('Mary', 21, 'F', 'Class B'),
  ('Tom', 19, 'M', 'Class A'),
  ('Susan', 22, 'F', 'Class B'),
  ('David', 20, 'M', 'Class C'),
  ('Julia', 19, 'F', 'Class C'),
  ('Alex', 21, 'M', 'Class A'),
  ('Olivia', 20, 'F', 'Class B'),
  ('Eric', 19, 'M', 'Class A'),
  ('Sophie', 21, 'F', 'Class C');

-- Insert data into the C table
INSERT INTO C (Cno, Cname, Cpreno, Credit) VALUES
  (101, 'Math', NULL, 3),
  (102, 'English', NULL, 2),
  (103, 'Science', 101, 4),
  (104, 'History', NULL, 3),
  (105, 'Geography', NULL, 2),
  (106, 'Art', NULL, 2),
  (107, 'Music', NULL, 2),
  (108, 'Physical Education', NULL, 1),
  (109, 'Computer Science', 101, 3),
  (110, 'Biology', 103, 4);

-- Insert data into the T table
INSERT INTO T (Tname) VALUES
  ('Mr. Smith'),
  ('Ms. Johnson'),
  ('Mr. Lee'),
  ('Ms. Chen'),
  ('Mr. Kim'),
  ('Ms. Park'),
  ('Mr. Rodriguez'),
  ('Ms. Garcia'),
  ('Mr. Wong'),
  ('Ms. Chan');

-- Insert data into the SC table
INSERT INTO SC (Sno, Cno, Tno, Grade) VALUES
  (1, 101, 1, 90),
  (1, 102, 2, 85),
  (2, 102, 3, 92),
  (3, 101, 1, 80),
  (3, 103, 4, 88),
  (4, 105, 5, 95),
  (4, 106, 6, 85),
  (5, 104, 7, 78),
  (6, 102, 8, 90),
  (7, 103, 9, 85),
  (1, 105, 8, 55),
  (2, 107, 4, 58),
  (3, 109, 6, 59),
  (4, 102, 7, 45),
  (5, 106, 3, 50),
  (6, 108, 5, 57),
  (7, 110, 2, 56),
  (8, 101, 1, 62),
  (9, 104, 3, 59),
  (10, 103, 9, 58);
```

1. 查找李力的所有不及格的课程名称和成绩，按成绩降序排列
   ```sql
   select Cname,Grade
   from Stu natural join SC natural join C
   where Sname="李力" and Grade<=60
   order by Grade desc;
   ```
2. 列出每门课的学分，选修的学生人数，及学生成绩的平均分
   ```sql
   select T.Cno,T.num,T.avg,Credit from (
       select Cno,count(*) num,avg(Grade) avg
       from SC
       group by Cno
   )T natural join C;
   ```
3. 选出所修课程总学分在10分以下的学生（注：不及格的课程没有学分）
   ```sql
   select Sno,sum(Grade*Credit/100)
   from SC natural join C
   where Grade>=60
   group by Sno
   having sum(Grade*Credit/100)<10;
   ```
4. 选出选课门数最多的学生学号及选课数量
   ```sql
   select Sno,count(*)
   from SC
   group by Sno
   having count(*)=(
       select count(*)
       from SC
       group by Sno
       order by count(*) desc
       LIMIT 1
   );
   ```
5. 列出每门课的最高分及获得该分数的学生
   ```sql
   select Cno,Sno,G from(
       select Cno,max(Grade) G
       from SC
       group by Cno
   )T natural join SC
   where Grade=G;
   ```
6. 选出物理课得分比所有男学生的物理课平均分高的学生姓名
   ```sql
   select Sname
   from Stu natural join SC natural join C
   where Sex='M' and Cname='Physical Education' and Grade>(
       select avg(Grade)
       from Stu natural join SC natural join C
       where Sex='M' and Cname='Physical Education'
   );
   ```
7. 选出修习过物理课的直接先修课的学生
   ```sql
   select Sno
   from SC
   where Cno in (
       select Cpreno
       from SC natural join C
       where Cname='Physical Education'
   );
   ```
8. 选出有两门以上先修课的课程（包括直接先修课、间接先修课）(用课程表)
   ```sql
   # 选出直接+间接先修课大于等于2门的课程+直接先修课就大于等于2门的课程
   select T.Cno
   from C join (
       select Cno,Cpreno
       from C
       where Cpreno is not NULL
   ) T on C.Cno=T.Cpreno
   where C.Cpreno is not NULL
   union
   select Cno
   from C
   where Cpreno is not NULL
   group by Cno
   having count(*)>=2;
   ```

> [!warning] 出现的问题总结
>
> 1. union的使用
> 2. 第八题双重查找的语法
> 3. 关于‘最’相关的查找方式
> 4. select语句中的数学运算以及group后的数学运算规则

![[SQL作业.pdf]]
