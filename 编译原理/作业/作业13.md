# 作业 13

> 参考 SysY 语言文法，设计类 C 语言风格的数组文法，及其对应的语义动作程序
> 注意：
> （1）说明符号表结构，和数组声明对应的填表动作
> （2）类 C 风格不考虑运行时越界检查，但需要数组使用时，在编译时检查维数个数
> （3）不使用数组模版，无需计算数组模版所需的 P(i)和 RC

具体文法如下

```txt
<type-specifier> ::= int | float | double | char | ...

<declarator> ::= <identifier> | <declarator> '[' <constant-expression> ']'

<constant-expression> ::= <integer-constant>

<statement> ::= <expression-statement> | ...

<expression-statement> ::= <expression> ';'

<expression> ::= <assignment-expression> | ...

<assignment-expression> ::= <conditional-expression> | <unary-expression> <assignment-operator> <assignment-expression>

<unary-expression> ::= <postfix-expression> | ...

<postfix-expression> ::= <primary-expression> | <postfix-expression> '[' <expression> ']'

<primary-expression> ::= <identifier> | <constant> | ...

<assignment-operator> ::= '='

<constant> ::= <integer-constant>

<integer-constant> ::= <digit>+

<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

```cpp
#define MAX_SYMBOLS 1000
#define MAX_DIMENSIONS 10

typedef struct {
    char name[32];
    int type;
    int dimensions[MAX_DIMENSIONS];
    int num_dimensions;
    int element_size;
    int size;
    int offset;
} symbol_t;

symbol_t symbol_table[MAX_SYMBOLS];
int num_symbols = 0;
// 将数组符号表项添加到符号表中，并为数组分配内存空间
int add_symbol(char *name, int type, int *dimensions, int num_dimensions) {
    symbol_t symbol;
    strcpy(symbol.name, name);
    symbol.type = type;
    symbol.num_dimensions = num_dimensions;
    symbol.element_size = type == INT ? sizeof(int) : sizeof(float);
    symbol.size = symbol.element_size;
    for (int i = 0; i < num_dimensions; i++) {
        symbol.dimensions[i] = dimensions[i];
        symbol.size *= dimensions[i];
    }
    symbol.offset = 0;
    for (int i = 0; i < num_symbols; i++) {
        if (strcmp(symbol_table[i].name, name) == 0) {
            return -1;
        }
        symbol.offset += symbol_table[i].size;
    }
    symbol_table[num_symbols++] = symbol;
    return 0;
}

symbol_t *find_symbol(char *name) {
    for (int i = 0; i < num_symbols; i++) {
        if (strcmp(symbol_table[i].name, name) == 0) {
            return &symbol_table[i];
        }
    }
    return NULL;
}
// 检查数组的维数是否正确
int check_array_dimensions(symbol_t *symbol, int *dimensions, int num_dimensions) {
    if (symbol->num_dimensions != num_dimensions) {
        return -1;
    }
    for (int i = 0; i < num_dimensions; i++) {
        if (symbol->dimensions[i] != dimensions[i]) {
            return -1;
        }
    }
    return 0;
}

int main() {
    int dimensions[] = {10, 20};
    add_symbol("a", INT, dimensions, 2);
    symbol_t *symbol = find_symbol("a");
    int dimensions2[] = {10, 20};
    if (check_array_dimensions(symbol, dimensions2, 2) != 0) {
        printf("Error: array dimensions do not match\n");
        exit(1);
    }
    printf("Array size: %d\n", symbol->size);
    return 0;
}
```

> 参考 C 语言文法，设计结构体（struct）声明的文法，及其对应的语义动作程序；以及声明结构体变量的文法和处理动作。
> 注意：
> （1）说明符号表结构，和 struct 声明、struct 类型变量声明的对应填表动作
> （2）思考自定义类型的填写是否需要写入符号表？为什么？
> （3）至少举出一个例子（包括 struct 定义和变量声明），说明对应的操作。

具体结构体声明和结构体变量的文法 👇🏻

```txt
<type-specifier> ::= int | float | double | char | struct <identifier>

<struct-declaration> ::= struct <identifier> '{' <struct-member-declarations> '}'

<struct-member-declarations> ::= <struct-member-declaration> | <struct-member-declarations> <struct-member-declaration>

<struct-member-declaration> ::= <type-specifier> <declarator> ';'

<declarator> ::= <identifier> | <declarator> '[' <constant-expression> ']'

<constant-expression> ::= <integer-constant>

<statement> ::= <expression-statement> | ...

<expression-statement> ::= <expression> ';'

<expression> ::= <assignment-expression> | ...

<assignment-expression> ::= <conditional-expression> | <unary-expression> <assignment-operator> <assignment-expression>

<unary-expression> ::= <postfix-expression> | ...

<postfix-expression> ::= <primary-expression> | <postfix-expression> '.' <identifier>

<primary-expression> ::= <identifier> | <constant> | ...

<assignment-operator> ::= '='

<constant> ::= <integer-constant>

<integer-constant> ::= <digit>+

<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

语义分析程序

```cpp
#define MAX_SYMBOLS 1000

typedef struct {
    char name[32];
    int type;
    int size;
    int offset;
} symbol_t;

typedef struct {
    char name[32];
    symbol_t members[MAX_SYMBOLS];
    int num_members;
    int size;
} struct_symbol_t;

struct_symbol_t struct_table[MAX_SYMBOLS];
int num_structs = 0;

symbol_t symbol_table[MAX_SYMBOLS];
int num_symbols = 0;

int add_struct(char *name, symbol_t *members, int num_members) {
    struct_symbol_t struct_symbol;
    strcpy(struct_symbol.name, name);
    struct_symbol.num_members = num_members;
    struct_symbol.size = 0;
    for (int i = 0; i < num_members; i++) {
        struct_symbol.members[i] = members[i];
        struct_symbol.size += members[i].size;
    }
    struct_table[num_structs++] = struct_symbol;
    return 0;
}

struct_symbol_t *find_struct(char *name) {
    for (int i = 0; i < num_structs; i++) {
        if (strcmp(struct_table[i].name, name) == 0) {
            return &struct_table[i];
        }
    }
    return NULL;
}

int add_symbol(char *name, int type, int size) {
    symbol_t symbol;
    strcpy(symbol.name, name);
    symbol.type = type;
    symbol.size = size;
    symbol.offset = 0;
    for (int i = 0; i < num_symbols; i++) {
        symbol.offset += symbol_table[i].size;
    }
    symbol_table[num_symbols++] = symbol;
    return 0;
}

symbol_t *find_symbol(char *name) {
    for (int i = 0; i < num_symbols; i++) {
        if (strcmp(symbol_table[i].name, name) == 0) {
            return &symbol_table[i];
        }
    }
    return NULL;
}

int main() {
    symbol_t members[] = {
        {"x", INT, sizeof(int)},
        {"y", INT, sizeof(int)}
    };
    add_struct("point", members, 2);
    struct_symbol_t *struct_symbol = find_struct("point");
    printf("Struct size: %d\n", struct_symbol->size);
    add_symbol("p", STRUCT, struct_symbol->size);
    symbol_t *symbol = find_symbol("p");
    printf("Symbol size: %d\n", symbol->size);
    return 0;
}
```
