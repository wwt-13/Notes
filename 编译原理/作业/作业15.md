# 作业 15

> 将以下代码切分为基本块，并画出流图

```python
x=1
i=0
if i>=10 goto (7)
x=x*i
i=i+1
goto (3)
if x>5000 goto (11)
RETURN_VAL=5000
return
goto (13)
RETURN_VAL=x
return
return
```

具体解答见图 👇🏻
![Alt text](<CleanShot 2023-11-04 at 09.50.41.png>)

> 按照算法 14.2 为图中所示代码序列建立 DAG 图，并详述构建过程
>
> 代码序列
> t1=-c
> t2=b\*t1
> t3=-c
> c=b\*t3
> t4=t2+c
> a=t4

以`<-`代表边，`[xxx]`代表 xxx 运算

| expression | DAG                             | node table                                                           |
| ---------- | ------------------------------- | -------------------------------------------------------------------- |
| t1=-c      | t1<-[-]<-c_0                    | {t1=>t1,c_0=>c_0}                                                    |
| t2=b\*t1   | t1<-[\*]<-t1<-[-]<-c_0          | { t1=>t1, t2=>t2, c_0=>c_0, b_0=>b_0 }                               |
| t3=-c      | t2<-[\*]<-t1<-[-]<-c_0          | { t1=>t1, t2=>t2, t3=>t1, c_0=>c_0, b_0=>b_0 }                       |
| c=b\*t3    | t2<-[\*]<-t1<-[-]<-c_0          | { t1=>t1, t2=>t2, t3=>t1, c_0=>c_0, c_1=>t2, b_0=>b_0 }              |
| t4=t2+c    | t4<-[+]<-t2<-[\*]<-t1<-[-]<-c_0 | { t1=>t1, t2=>t2, t3=>t1, t4=>t4, c_0=>c_0, c_1=>t2, b_0=>b_0}       |
| a=t4       | t4<-[+]<-t2<-[\*]<-t1<-[-]<-c_0 | { t1=>t1, t2=>t2, t3=>t1, t4=>t4, c_0=>c_0, c_1=>t2, b_0=>b_0,a=>t4} |

最终 DAG 图为

```
     v----\
t4<-[+]<-t2<-[*]<-t1<-[-]<-c_0
              ^----b_0
```

> 为以下四元式序列构建 DAG 图，并采用算法 14. 3 所介绍的启发式算法重新导出中间代码，需简述中间代码的导出过程
>
> t1=a
> t2=t1\*2
> b=a
> t3=b\*2
> t4:=t2+t3
> a:=t4
> t5=t1\*2
> t6=b+t5
> b=t6

导出代码

```
t2=a_0*2
t4=t2+t2
t6=a_0+t2
```

导出中间节点序列

```
[]
[a_0]
[a_0,2]
[a_0,2,t2]
[a_0,2,t2,t4]
[a_0,2,t2,t4,t6]
```

变量表

```
{
    a_0=>a_0,
    t1=>a_0,
    t2=>t2,
    b_0=>a_0,
    t3=>t2,
    t4=>t4,
    a_1=>t4,
    t5=>t2,
    t6=>t6,
    b_1=>t6
}
```

DAG 图

```
     v----\
t4<-[+]<-t2<-[*]<-----a_0
              ^----2  /
  t6<-[+]<------------/
```

> 附加题：分析 bitset.c 中可优化的点

```c
#include <stdio.h>
#include <time.h>
int set(int a[], int pos, int d)
{
    const int bitcount = 30;

    int x[31] = {};

    x[0] = 1;

    x[1] = x[0] * 2;

    x[2] = x[1] * 2;

    x[3] = x[2] * 2;

    x[4] = x[3] * 2;

    x[5] = x[4] * 2;

    x[6] = x[5] * 2;

    x[7] = x[6] * 2;

    x[8] = x[7] * 2;

    x[9] = x[8] * 2;

    x[10] = x[9] * 2;

    int i = 10;

    while (i < bitcount)
    {

        i = i + 1;

        x[i] = x[i - 1] * 2;
    }

    int v = 0;

    if (pos / bitcount >= 10000)
        return 0;

    if (a[pos / bitcount] / (x[pos % bitcount]) % 2 != d)
    {

        if (a[pos / bitcount] / (x[pos % bitcount]) % 2 == 0)
            if (d == 1)

                v = x[pos % bitcount];

        if (a[pos / bitcount] / x[pos % bitcount] % 2 == 1)

            if (d == 0)

                v = v - x[pos % bitcount];
    }

    a[pos / bitcount] = a[pos / bitcount] + v;

    return 0;
}

int seed[3] = {19971231, 19981013, 1000000000 + 7};

int staticvalue = 0;
int rand()
{
    staticvalue = staticvalue * seed[0] + seed[1];
    staticvalue = staticvalue % seed[2];
    if (staticvalue < 0)
        staticvalue = seed[2] + staticvalue;
    return staticvalue;
}

int a[10000] = {};
int main()
{

    freopen("bitset.in", "r", stdin); // int n = getint();
    int n;
    scanf("%d", &n); // staticvalue = getint();
    scanf("%d", &staticvalue);
    clock_t start = clock();
    int x, y;
    while (n > 0)
    {

        n = n - 1;

        x = rand() % 300000;

        y = rand() % 2;

        set(a, x, y);
    }
    clock_t finish = clock();
    printf("%.3f ", (double)(finish - start) / CLOCKS_PER_SEC); // putarray(10000, a);
    return 0;
}
```

1. 在 set 函数中，bitcount 被设置为常量 30，这个值在函数中没有改变，因此可以使用`#define bitcount 30`，使得在编译时计算所有使用 bitcount 的表达式，而不是在运行时计算
2. 可以将 set 函数中的 while 展开减少循环控制的开销
3. 可以将 rand 函数内联减少调用开销
4. `a[pos/bitcount]`和`(x[pos%bitcount])%2`被多次计算，可以将结果存储在变量中
