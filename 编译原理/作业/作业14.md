# 作业 14

> 写出类 C 语言函数调用中的 return 语句的属性翻译文法及其处理动作程序。
>
> 提示：请说明你对运行栈函数调用的调用约定，caller 方要做什么，callee 方要做什么

属性翻译文法

```txt
<statement> ::= <expression-statement> | <return-statement> | ...

<expression-statement> ::= <expression> ';'

<return-statement> ::= return <expression> ';'
```

处理动作程序

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SYMBOLS 1000
#define MAX_STACK_SIZE 1000

typedef struct {
    char name[32];
    int type;
    int size;
    int offset;
} symbol_t;

symbol_t symbol_table[MAX_SYMBOLS];
int num_symbols = 0;

int stack[MAX_STACK_SIZE];
int sp = 0;

int push(int value) {
    stack[sp++] = value;
    return 0;
}

int pop() {
    return stack[--sp];
}

int add_symbol(char *name, int type, int size) {
    symbol_t symbol;
    strcpy(symbol.name, name);
    symbol.type = type;
    symbol.size = size;
    symbol.offset = 0;
    for (int i = 0; i < num_symbols; i++) {
        symbol.offset += symbol_table[i].size;
    }
    symbol_table[num_symbols++] = symbol;
    return 0;
}

symbol_t *find_symbol(char *name) {
    for (int i = 0; i < num_symbols; i++) {
        if (strcmp(symbol_table[i].name, name) == 0) {
            return &symbol_table[i];
        }
    }
    return NULL;
}

int main() {
    add_symbol("x", INT, sizeof(int));
    push(1);
    symbol_t *symbol = find_symbol("x");
    int *address = (int *) (stack + sp);
    *address = pop();
    printf("x = %d\n", *address);
    return 0;
}
```

在函数调用中，`caller` 方需要将函数参数压入栈中，并将返回地址压入栈中，然后跳转到函数入口地址。`callee` 方需要在进入函数时，将栈帧指针压入栈中，并为局部变量分配内存空间。在函数返回时，`callee` 方需要将返回值存储到指定的位置，并将栈帧指针弹出栈中，然后跳转到返回地址

> 写出类 C 语言 for 语句的属性翻译文法及其处理动作程序（含 break 和 continue）

属性翻译文法

```txt
<statement> ::= <expression-statement> | <for-statement> | <break-statement> | <continue-statement> | ...

<expression-statement> ::= <expression> ';'

<for-statement> ::= for '(' <expression> ';' <expression> ';' <expression> ')' <statement>

<break-statement> ::= break ';'

<continue-statement> ::= continue ';'
```

处理动作程序

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STACK_SIZE 1000

int stack[MAX_STACK_SIZE];
int sp = 0;

int push(int value) {
    stack[sp++] = value;
    return 0;
}

int pop() {
    return stack[--sp];
}

int main() {
    for (int i = 0; i < 10; i++) {
        if (i == 5) {
            break;
        }
        if (i == 3) {
            continue;
        }
        printf("%d\n", i);
    }
    return 0;
}
```
