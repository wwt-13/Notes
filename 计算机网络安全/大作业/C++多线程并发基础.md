[toc]

# C++多线程并发基础

>   **线程**是操作系统能够进行CPU调度的**最小单位**，它被**包含在进程之中**，一个进程可包含单个或者多个线程。

```bash
# 筛选特定进程
# 注意awk应该是单引号，NR==1是表头
ps -efL | awk 'NR==1||$2==26908'
```

![CleanShot 2024-05-24 at 09.56.06](/Users/wwt13/Documents/Notes/assets/CleanShot 2024-05-24 at 09.56.06.png)

其中*LWP*是线程id

如果使用detach()，就必须保证线程结束之前可访问数据的有效性，使用指针和引用需要格外谨慎

**产生死锁的四个必要条件（面试考点）：**

1.  互斥（资源同一时刻只能被一个进程使用）
2.  请求并保持（进程在请资源时，不释放自己已经占有的资源）
3.  不剥夺（进程已经获得的资源，在进程使用完前，不能强制剥夺）
4.  循环等待（进程间形成环状的资源循环等待关系）

## 经典同步互斥问题

### 生产者-消费者问题

>   若干进程通过有限的共享缓冲区交换数据。其中，“生产者”进程不断写入，而“消费者”进程不断读出；共享缓冲区共有N个；任何时刻只能有一个进程可对共享缓冲区进行操作。

需要保证一下三点👇🏻

1.   生产者之间：放置产品互斥
2.   消费者之间：取出产品互斥
3.   生产者和消费者之间：对产品操作互斥，且放置取出要求同步（需要有先放后取的顺序）

```c
// 信号量设置
S mutex=1;
S empty=N; // 空闲数量
S full=0; // 产品数量

// 每次对产品进行放置和取出都要保证互斥
// 并且保证对产品的操作同步
// 要尽量减少锁的保护范围，并且如果P(mutex)在P(full)前面的话，会直接进入盲等
P(empty);
P(mutex);
input();
V(mutex);
V(full);

P(full)
P(mutex);
output();
V(mutex);
V(empty);
```

#### 代码实现

>   生产者用于生产数据，生产一个就往共享数据区存一个，如果共享数据区已满的话，生产者就暂停生产，等待消费者的通知后再启动。
>
>   消费者用于消费数据，一个一个的从共享数据区取，如果共享数据区为空的话，消费者就暂停取数据，等待生产者的通知后再启动。
>
>   生产者与消费者不能直接交互,它们之间所共享的数据使用队列结构来实现;



### 读者-写者问题

>   对共享资源的读写操作，任一时刻“写者”最多只允许一个，而“读者”则允许多个

需要实现一下几点👇🏻

1.   读写互斥？三大处理策略
     -   读者优先：读进程可以并发地读取数据，而写进程必须等待所有读进程完成后才能进行写操作
     -   写者优先：写进程优先于读进程。如果有写进程等待，新的读进程必须等待写进程完成后才能开始读取数据
     -   公平策略：读进程和写进程按照到达的顺序进行操作，避免长时间的饥饿现象，实用✅
2.   写写互斥：只允许一个人写

**读优先策略**

```c
// 信号量
S wmutex=1;
S mutex=1;
// 代表有多少个读进程被激活
readcount=0;

// Writer
P(wmutex);
write();
V(wmutex);

// Reader
// 现在觉得 readcount是共享变量啊大哥，加个锁不是必须的么，不然两进程同时+1最终结果只+1咋办啊啊啊啊啊
P(mutex);
if readcount=0 then P(wmutex);
readcount:=readcount+1;
V(mutex);
read();
P(mutex);
readcount:=readcount+1；
if readcount=0 then V(wmutex);
V(mutex);
```

***公平策略***

>   【【操作系统】以版本迭代方式轻松理解PV操作读者写者问题】 https://www.bilibili.com/video/BV1yh4y1a7Xf/?share_source=copy_web&vd_source=5b3554312b82478c4845c464e45d8893

1.   出现写者后，新读者要排在该写者后面进行调度（也就是不允许执行readcount++）

```c
// 信号量
S wmutex=1;
S rwmutex=1;
S mutex=1;
// 代表有多少个读进程被激活
readcount=0;

// Writer
P(rwmutex);
P(wmutex);
write();
V(wmutex);
V(rwmutex);

// Reader
// 现在觉得 readcount是共享变量啊大哥，加个锁不是必须的么，不然两进程同时+1最终结果只+1咋办啊啊啊啊啊
P(rwmutex);
P(mutex);
if readcount=0 then P(wmutex);
readcount:=readcount+1;
V(mutex);
V(rwmutex);
read();
P(mutex);
readcount:=readcount-1；
if readcount=0 then V(wmutex);
V(mutex);
```

### 哲学家就餐问题

>   -   5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；
>
>   -   哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两只筷子，思考时则同时将两支筷子放回原处
>   -   如何保证哲学家们的动作有序进行？ 
>       1.   不出现相邻者同时进餐
>       2.   不出现有人永远拿不到筷子



#### 哲学家进餐实际问题

## 生产者-消费者拓展问题

>   设有一个可以装A、B两种物品的仓库,其容 量无限大,但要求仓库中A、B两种物品的数量满足下述不等式: -M<A-B<N
>
>   试用信号量和PV操作描述A、B两种物品的 入库过程

```python
S mutex=1,sa=N,sb=M;

A:
while(true)
    P(sa)
    P(mutex)
    in(A)
    V(mutex)
    V(sb)

B:
while(true)
    P(sb)
    P(mutex)
    in(B)
    V(mutex)
    V(sa)
```

### 理发师问题

>   -   理发店里有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子
>   -   如果没有顾客，理发师便在理发椅上睡觉，当一个顾客到来时，叫醒理发师
>   -   如果理发师正在理发时，又有顾客来了，则如果有空椅子可以坐，就坐下来等待，否则就离开。

