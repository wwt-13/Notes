# Raid 阵列

> 参考资料：https://zq99299.github.io/linux-tutorial/tutorial-basis/14/02.html#raid-5%EF%BC%9A%E6%95%88%E8%83%BD%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E7%9A%84%E5%9D%87%E8%A1%A1%E8%80%83%E8%99%91

> 长期频繁读写一块磁盘，极易造成磁盘故障和数据丢失。所以综合存储容量、性能、可靠性和成本考虑，利用虚拟化存储技术，把多块硬盘组合起来，形成一个或多个阵列组，提升了性能和冗余性，这个技术就是  RAID  磁盘冗余阵列（Redundant Array of Inexpensive Disks）
>
> 虚拟化技术.....
>
> Raid 就是一个包含多块硬盘组成的冗余阵列，它把多块固态硬盘组合成一块逻辑硬盘，从应用层来看，就像是使用一块实体硬盘一样，但是它的性能和可靠性都比单块硬盘要好很多。

> Raid 特点：
>
> 1. 数据安全：一般而言，同一份数据在其他磁盘上会有冗余备份(不是所有的 Raid 都具备)
> 2. 提高性能：多块硬盘并行读写，提高了性能

## Raid0: 等量 stripe

> 性能最好的 Raid，也是最不安全的 Raid（只是简单的将文件等量存储在多个磁盘里，而不做任何备份）
>
> RAID 将磁盘切出等量的区块（chunk），一般可设置为 4K~1M 之间，当一个文件要写入 RAID 时，该文件会依据 chunk 的大小切割好，再依序放到各个磁盘里(会优先等量存放到各个磁盘上去)，当然，这样的存储方式也使得只要有任意一块磁盘上的数据出现损坏，该文件就无法读取了。
>
> 同型号同容量组 Raid0 的效果是最好的(可以保证所有磁盘同时存满)
>
> 磁盘数>=2

![Alt text](https://zq99299.github.io/linux-tutorial/assets/img/image-20200227143813650.a20095d6.png)

## Raid1: 镜像 mirror

> Raid1 是最简单的 Raid，也是最安全的 Raid，它会将数据完整的复制到每一块磁盘上，所以只要有一块磁盘正常，该文件就可以正常读取。
>
> 建议使用相同磁盘容量，最好是一样的磁盘，如果是不同容量的磁盘组成，那么总容量将以最小的那一块为主
>
> 缺点在于，如果是软件实现的阵列，写入效能较差(因为要写入两次)，当然如果是磁盘阵列卡的话就还好
>
> 磁盘数>=2

![Alt text](https://zq99299.github.io/linux-tutorial/assets/img/image-20200227144535061.022d6273.png)

## Raid1+0,Raid0+1

> Raid0: 性能好，数据不安全
> Raid1: 数据安全，性能差
>
> 将两者结合起来就形成了：
>
> Raid1+0: 先将磁盘分为两组，每组两块磁盘组 Raid1，然后再将两组磁盘组成 Raid0
> Raid0+1: 先将磁盘分为两组，每组两块磁盘组 Raid0，然后再将两组磁盘组成 Raid1
>
> 显然 Raid1+0 结合了 Raid0 和 Raid1 的优点，性能好，数据安全，至于 Raid0+1 就不用说了 😅
>
> 除非一组的磁盘全部损坏，否则数据都是安全的
>
> _这也是目前存储设备厂商推荐的方法_

![Alt text](https://zq99299.github.io/linux-tutorial/assets/img/image-20200227145429427.c0786c46.png)

## Raid5: 效能与数据备份的均衡考虑

> 数据写入类似 Raid0，只不过需要额外的一块磁盘来存储校验码，这样就可以保证数据的完整性了，该存储校验码 P=D1^D2^D3....Dn，同理当 Di 数据损坏时，就可以通过异或的性质 Di=D1^D2^....Dn^P 来恢复数据了
>
> 校验码可以随机存储在不同磁盘上（这是 Raid5,存储在同一块就是 Raid3）
>
> 优点：性能好，数据安全
> 缺点：只能支持一块磁盘的损坏，如果有两块磁盘损坏，那么数据就无法恢复了
