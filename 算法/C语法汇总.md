[toc]

# C语法汇总

>   C语言是一种被广泛使用的专业语言，以其具备极大教育意义和运行效率极高（几乎等同于汇编语言）而闻名，本文将对C语言的基本语法、各个常用标准库等等进行基本介绍[^参考网页]
>
>   *<font color="orange">Tip:</font>对于基础语法的练习刷题，可以看这里[^NOI基础语法]*
>
>   *<font color="orange">Tip:</font>C语言是为了编写UNIX操作系统而发明的，作者是Dennis Ritchie* 

## 环境配置

>   具体配置步骤见<a href="/Users/wwt13/Documents/Notes/Mac/Mac配置C&C++环境.md">Mac配置C/C++环境</a>

## 程序结构

>   在正式开始学习C语言的语法之前，还需要了解一下C语言程序的基本结构。

C程序主要包括以下几个部分：

1.   *预处理器指令*：用于告诉C编译器在实际编译之前要包含的各种*头文件*

     ```c
     #include<stdio.h>
     #include<stdlib.h>
     ```

2.   主函数main：程序执行的入口

     ```c
     int main(){
     }
     ```

3.   变量

     ```c
     int i,j;
     long ll;
     ```

4.   语句&表达式

5.   注释：会被编译器忽略的内容，在这里放置你想要说明的部分。

```c
#include<stdio.h>//预处理器指令
int main(){//主函数，程序执行的入口
    printf("Hello,World!");
    return 0;//终止main函数
}
```

## 基本符号

>   讲解C语言中标识符等最基本标记符号的含义。

|      符号       |                             含义                             |
| :-------------: | :----------------------------------------------------------: |
|      `//`       |                            行注释                            |
| `/* content */` |                            块注释                            |
|       `;`       |                   一行C语句的*结束*标识符                    |
|       `_`       | 一般用于标识变量、函数，或者任何用户自定义的项目名称的分隔符，例如`_test`,`my_name`,`a_123`等，需要注意的是，C标识符内不允许出现标点符号，也不允许以数字开头 |

### 运算符

>   C语言内置了丰富的运算符，并提供了以下类型的运算符
>
>   -   算术运算符：过于简单，直接略过
>   -   关系运算符：过于简单，直接略过
>   -   逻辑运算符：过于简单，直接略过
>   -   **位运算符**：需要好好理解一下
>   -   赋值运算符：就是算术运算符和=的结合，同样非常简单，直接略过
>   -   **杂项运算符**：C语言支持的一些其他运算符，需要讲解

#### 位运算符

>   指二进制进行的运算，在系统软件中，常常需要处理二进制位的问题。C语言提供了6个位操作运算符。这些运算符只能用于*整型操作数*，即只能用于带符号或无符号的char,short,int与long类型
>
>   *<font color="orange">Tip:</font>合理的使用位运算符可以大大提高程序的运行效率。*
>
>   *<font color="red">Attention:</font>移位运算符的优先级很高，和其他位运算符不太一样*

| 运算符 |  含义  |                             描述                             |                        用途                         |
| :----: | :----: | :----------------------------------------------------------: | :-------------------------------------------------: |
|  `&`   | 按位与 |   如果两个相应的二进制位都为1，则该位的结果值为1，否则为0    |             保留某些位或者对某些位清零              |
|  `｜`  | 按位或 |      两个相应的二进制位中只要有一个为1，该位的结果值为1      |             保留某些位或者对某些位置一              |
|  `^`   |  异或  |         若参加运算的两个二进制位值相同则为0，否则为1         |                对某些位进行反转操作                 |
|  `~`   |  取反  |   一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0   |                          -                          |
|  `<<`  |  左移  |          用来将一个数的各二进制位全部左移N位，右补0          | 不存在被丢弃高位的情况下，左移n位相当于乘以2的n次方 |
|  `>>`  |  右移  | 将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0 | 不存在被丢弃低位的情况下，右移n位相当于除以2的n次方 |

#### 杂项运算符

|   运算符   |       描述       |                 实例                 |
| :--------: | :--------------: | :----------------------------------: |
| `sizeof()` | 返回变量的大小。 | sizeof(a) 将返回 4，其中 a 是整数。  |
|    `&`     | 返回变量的地址。 |       &a将给出变量的实际地址。       |
|    `*`     |  指向一个变量。  |          *a将指向一个变量。          |
|  ` ? : `   |    条件表达式    | 如果条件为真 ? 则值为 X : 否则值为 Y |

#### 运算符优先级

>   越上面的运算符优先级越高

|    类别    |              运算符               |  结合性  |
| :--------: | :-------------------------------: | :------: |
|    后缀    |         () [] -> . ++ - -         | 从左到右 |
|    一元    |  + - ! ~ ++ - - (type)* & sizeof  | 从右到左 |
|    乘除    |               * / %               | 从左到右 |
|    加减    |                + -                | 从左到右 |
|  **移位**  |               << >>               | 从左到右 |
|    关系    |             < <= > >=             | 从左到右 |
|    相等    |               == !=               | 从左到右 |
|  位与 AND  |                 &                 | 从左到右 |
| 位异或 XOR |                 ^                 | 从左到右 |
|  位或 OR   |                \|                 | 从左到右 |
| 逻辑与 AND |                &&                 | 从左到右 |
| 逻辑或 OR  |               \|\|                | 从左到右 |
|    条件    |                ?:                 | 从右到左 |
|    赋值    | = += -= *= /= %=>>= <<= &= ^= \|= | 从右到左 |
|    逗号    |                 ,                 | 从左到右 |

### 输入输出格式

>   虽然很多时候转换符弄错也能得到正确输出，但是还是要了解一下正确的转换符

#### 格式说明符

| 转换说明 |                            输 出                             |
| :------: | :----------------------------------------------------------: |
|   `%c`   |                           一个字符                           |
|   `%d`   |                       有符号十进制整数                       |
|  `%e/E`  |                       浮点数、e-记数法                       |
|   `%f`   |                     浮点数，十进制记数法                     |
|  `%g/G`  | 根据数值不同自动选择%f或者%e。%e格式在指数小于-4或者大于等于精度时使用 |
|   `%o`   |                       无符号八进制整数                       |
|   `%p`   |                     **指针(就是指地址)**                     |
|   `%s`   |                            字符串                            |
|   `%u`   |                       无符号十进制整数                       |
|  `%x/X`  |           使用十六进制数字0f 的无符号十六进制整数            |

#### printf修饰符

|   修饰符    |                            意 义                             |
| :---------: | :----------------------------------------------------------: |
| `digit(s)`  | 字段宽度的最小值。如果该字段不能容纳要打印的数或者字符串，系统会使用更宽的字段。示例：“%4d” |
| `.digit(s)` | 精度。对于%e、%E和%f转换，是将要在小数点的右边打印的数字的位数。对于%g和%G转换，是有效数字的最大位数。对于%s转换，是将要打印的字符的最大数目。对于整数转换，是将要打印的数字的最小位数；如果必要，要使用前导零来达到这个位数。只使用“**.**”表示其后跟随一个零，所以%.f与%.0f相同。示例：“%5.2f”打印一个浮点数，他的字段宽度为5个字符，小数点后有两个数字。 |
|     `h`     | 和整数转换说明符一起使用，表示一个**short int** 或者 **unsigned short int** 类型数值。示例：“%hu”、“%hx”和“%6.4hd” |
|    `hh`     | 和整数转换说明符一起使用，表示一个**signed char** 或者**unsigned char**类型数值。示例：“%hhu”、“%hhx”和“%6.4hhd” |
|     `j`     | 和整数转换说明符一起使用，表示一个intmax_t或uintmax_t值。示例：“%jd”和“%8jX” |
|     `l`     | 和整数说明符一起使用，表示一个**long int** 或者**unsigned long int** 类型值。示例：“%ld”和“%8lu” |
|    `ll`     | 和整数说明符一起使用，表示一个**long long int**或 **unsigned long long int** 类型值 (C99)。示例：“%lld”和“%8llu” |
|     `L`     | 和浮点转换说明符一起使用，表示一个**long double**值。示例：“%Lf”和“%10.4Le” |
|     `t`     | 和整数转换说明符一起使用，表示一个ptrdiff_t值(与两个指针之间的差相对应的类型) (C99)示例：“%td”和“%12ti” |
|     `z`     | **和整数转换说明符一起使用，表示一个size_t值(sizeof返回的类型) (C99)。示例：“%zd”和“%12zx”** |

#### printf标志

| 修饰符 |                            意 义                             |
| :----: | :----------------------------------------------------------: |
|  `-`   | 项目是左对齐的，也就是说，会把项目打印在字段的左侧开始处。示例：“%-20s” |
|  `+`   | 有符号的值若为正，则显示带加号的符号；若为负，则带减号的符号。示例：“%+6.2f” |
| (空格) | 有符号的值若为正，则显示时带前导空格(但是不显示符号)；若为负，则带减号符号。+标志会覆盖空格标志。示例：“% 6.2f” |
|  `#`   | 使用转换说明的可选形式。若为%o格式，则以0开始；若为%x和%X格式，则以0x或0X开始，对于所有的浮点形式，#保证了即使不限任何数字，也打印一个小数点字符。对于%g和%G格式，它防止尾随零被删除。示例：“%#o”、“%#8.0f”和“%+#10.3E” |
|  `0`   | 对于所有的数字格式，用前导零而不是用空格填充字段宽度。如果出现-标志或者指定了精度(对于整数)则忽略该标志。示例：“%010d”和“%08.3f” |

#### scanf的转换说明符

|   转换说明符    |                            意 义                             |
| :-------------: | :----------------------------------------------------------: |
|      `%c`       |                     把输入解释成一个字符                     |
|      `%d`       |               把输入解释成一个有符号十进制整数               |
| %e，%f，%g， %a |             把输入解释成一个浮点数 (%a是C99标准)             |
| %E，%F，%G，%A  |             把输入解释成一个浮点数 (%A是C99标准)             |
|      `%o`       |              把输入解释成一个**有符号**八进制数              |
|      `%p`       |                  把输入解释成一个指针(地址)                  |
|      `%s`       | 把输入解释成一个字符串；输入的内容以一个非空白字符作为开始，并且包含知道下一个空白字符的全部字符 |
|      `%u`       |               把输入解释成一个无符号十进制整数               |
|    `%x，%X`     |            把输入解释成一个**有符号**十六进制整数            |

#### scanf的转换修饰符

|   修饰符   |                            意 义                             |
| :--------: | :----------------------------------------------------------: |
|     *      |                    滞后赋值。示例：“%*d”                     |
| `digit(s)` | 最大字段宽度；在达到最大字段宽度或者遇到第一个空白字符时(不管哪一个先发生都一样)停止对输入项的读取。示例：“%10s” |
|    `hh`    | 把整数读作signed char 或 unsigned char 。示例：“%hhd”“%hhu”  |
|    `ll`    | 把整数读作long long或者 unsigned long long (C99)。示例：“%lld”“%llu” |
| `h，l或L`  | “%hd”和“hi”指示该值将会存储在一个short int中。“%ho”“%hx”和“%hu”指示该值将会存储在一个unsigned short int中。“%ld”和“%li”指示该值将会存储在一个long中。“%lo”“%lx”和“%lu”指示该值将会存储在一个unsigned long中。“%le”“%lf”和“%lg”指示该值以double类型存储。将L(而非l)与e、f和g一起使用指示该值以long double类型存储。如果没有这些修饰符，d、i、o和x指示int类型，而e、f和g指示float类型。 |

## 数据类型

>   在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。
>
>   *<font color="brown">Quote:</font>https://www.w3cschool.cn/c/c-data-types.html*

C中的数据类型可以分为以下几种：`基本类型`（是算术类型，包括了*整数类型*和*浮点类型*）、`枚举类型`（也是算术类型，被*用来定义在程序中只能赋予其一定的离散整数值的变量*）、`void类型`（用于说明*无可用的值*）、`派生类型`（包括**指针类型、数组类型、结构类型、共用体类型和函数类型**）

### 整数类型

>    下表列出了关于标准整数类型的存储大小和值范围的细节
>
>   *<font color="green">Ps:</font>C语言中可以通过sizeof函数来查看对应对象或类型的存储字节大小* 

|       类型       |   存储大小   |                        值范围                        |
| :--------------: | :----------: | :--------------------------------------------------: |
|      `char`      |    1 byte    |               -128 到 127 或 0 到 255                |
| `unsigned char`  |    1 byte    |                       0 到 255                       |
|  `signed char`   |    1 byte    |                     -128 到 127                      |
|      `int`       | 2 或 4 bytes | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
|  `unsigned int`  | 2 或 4 bytes |          0 到 65,535 或 0 到 4,294,967,295           |
|     `short`      |   2 bytes    |                  -32,768 到 32,767                   |
| `unsigned short` |   2 bytes    |                     0 到 65,535                      |
|      `long`      |   4 bytes    |           -2,147,483,648 到 2,147,483,647            |
| `unsigned long`  |   4 bytes    |                  0 到 4,294,967,295                  |

![CleanShot 2022-08-16 at 16.38.50](/Users/wwt13/Documents/Notes/assets/CleanShot 2022-08-16 at 16.38.50.gif)

#### 关于值范围的问题

>   观察上面列举出的整数类型可以发现，*所有的值范围都不是对称的*，表示负数的范围永远比表示正数的范围大出一个，下面来解释一下其中的原因。
>
>   *<font color="red">Attention:</font>理解该问题之前建议先理解<a href="/Users/wwt13/Documents/Notes/操作系统/原码、反码、补码.md">原码、反码、补码的含义和基本计算</a>*

***以int的范围为例：以4字节的int举例，范围为-2147483648—2147483647，等价于-2^31^—2^31^-1***

首先，4字节的int，共32位，*总共可以表示$2^{32}$个数*，这点是非常确定的。

因为是补码表示（最高位为符号位），正数方面和原码一致，所以从$0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001$到$0111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111$，范围是1到2147483647，共表示了$2^{31}-1$个数。

此时还剩下，$2^{31}+1$个数可以用于表示，除去	$0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000$用于表示0外，也就是说用于表示负数的二进制数有$2^{31}$个，==此时已经可以下结论了，$-2^{31}到2^{31}-1$的范围是肯定没问题的==（毕竟总不可能出现跳跃式表示的情况吧，那根本不合逻辑）

俗话说得好—“对任何问题都要刨根问底”，负数方面的补码表示又是如何一一对应的呢，-1的原码是$1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001$，补码为原码数值位取反+1，为$1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111$，-2、-3、-4、-5均可以此类推，但是在$-2^{31}$出现了特例，它的原码为$1\ 1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000$，是**33位的**，取反+1得到的数也是$1\ 1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000$，按道理讲，是找不到二进制数和$-2^{31}$对应的，但是巧合的是，二进制中，0有两种表示方法，+0和-0，-0的表示方式刚好为$-2^{31}$的补码的低32位$1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000$，并且该表示方式也未使用过，于是就顺理成章的将-0的表示方式作为最小负数来进行表示，到此就解决了负数和二进制数的一一对应问题。

***<font color="red">Attention:</font>$-2147483648$的补码表示为$1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000$，但是该补码并不是真正的补码，真正的补码应该是33位的那一个，同理，该数在32位下也不存在原码和反码***

至此，关于数据类型的取值范围问题已彻底解决，其余long、char的均可类推。

### 浮点类型

>   下表列出了关于标准浮点类型等存储大小、值范围和精度的各类细节。
>
>   *<font color="green">Ps:</font>似乎不存在long float这种数据类型* 

|     类型      |                 存储大小                 |            值范围            |   精度   |
| :-----------: | :--------------------------------------: | :--------------------------: | :------: |
|    `float`    |                  4byte                   |   $1.2E^{-38}～3.4E^{+38}$   | 6位小数  |
|   `double`    |                  8byte                   |  $2.3E^{-308}～1.7E^{+308}$  | 15位小数 |
| `long double` | 10byte（但是本机运行的结果和此结果不同） | $3.4E^{-4932}～1.1E^{+4932}$ | 19位小数 |

*<font color="orange">Tip:</font>在头文件`float.h`中定义了各种浮点数有关的宏，在程序中可以使用这些相关宏来了解C语言中浮点数的各种细节*

```c
#include <stdio.h>
#include <float.h>

int main()
{
   printf("Storage size for float : %d \n", sizeof(float));
   printf("Minimum float positive value: %E\n", FLT_MIN );
   printf("Maximum float positive value: %E\n", FLT_MAX );
   printf("Precision value: %d\n", FLT_DIG );
   //了解即可，具体细节方面的不必深究
   return 0;
}
```

 ![CleanShot 2022-08-17 at 10.23.28](/Users/wwt13/Documents/Notes/assets/CleanShot 2022-08-17 at 10.23.28.gif)

### void类型

>   void类型用于指定没有可用的值。
>
>   -   指定函数的返回为null（比方说纯输出函数）
>   -   指定函数的参数为null（比方说不接受参数的函数）
>   -   ==指定指针指向为null==（该操作需要了解c中指针的使用再来理解）

## 常量

>   介绍C中的各种常量类型和C中常量的定义方式（*#define预处理器*和*const关键字*）

### 整数常量

>   按道理来说整数常量是最简单的常量类型，但是为什么还要单独列举一个标签来说明呢？
>
>   需要⚠️的有两点，那就是**不同进制的整数表示前缀**和**有无符号整数的表示后缀**

```shell
1000 # 基本十进制数的表示
100u # 10进制无符号数的表示，u大小写均可
100l # l表示长整数，同样大小写均可(没啥用)
# ul可组合，顺序随意
0213 # 基本八进制整数表示，前缀为‘0’
0x1f # 基本十六进制数表示，前缀为‘0x’，x大小写均可
```

### 浮点常量

>   浮点常量有整数部分、小数部分和指数部分组成，可以使用*小数*形式和*指数*形式来表示浮点常量。

```shell
3.1232   # 标准的小数形式浮点数
123e-12  # 指数形式浮点数，其实就是利用e来表示科学记数法
.3e-5   # 同样合法
```

### 字符常量

>   字符常量是括在单引号中，例如，'x' 可以存储在 **char** 类型的简单变量中
>
>   一个字符在内存中只占一个字节。
>
>   字符常量分为普通字符（‘a’）和转义字符（‘\n’），当然字符常量也可以使用通用字符的形式来表示（例如‘\u02c0’）

---

***什么是转义字符？***

>   *转义字符*就是标志着*转义序列*开始的那个字符。转义字符是很多程序语言、数据格式和通信协议的[形式文法](https://zh.wikipedia.org/wiki/形式文法)的一部分。对于一个给定的[字母表](https://zh.wikipedia.org/wiki/字母表_(计算机科学))，**一个转义字符的目的是开始一个字符序列，使得转义字符开头的该字符序列具有不同于该字符序列单独出现（没有转义字符开头）时的语义**（比方说，`n`单独出现的时候只是作为一个普通的字母，但是如果和转义字符`\`相连得到的`\n`则代表的是换行符）
>
>   在C语言中，使用反斜杠“\”作为转移字符。

---

*常用转义字符序列*

| 转义序列 |  含义  | ascii码值(十进制) | 通用字符表示 |
| :------: | :----: | :---------------: | :----------: |
|   `\\`   | \ 字符 |        92         |   `\u005c`   |
|   `\'`   | ' 字符 |        39         |   `\u0027`   |
|   `\"`   | " 字符 |        34         |   `\u0022`   |
|   `\?`   | ? 字符 |        63         |   `\u003f`   |
|   `\n`   | 换行符 |        10         |   `\u000a`   |

### 字符串常量

>   字符串常量是用“双撇号”括起来的多个字符的序列，如"How are you"、"I love you"、"你好”，看起来就是简单的把多个字符串接在一起。
>
>   但是C语言规定，***在每一个字符串常量的结尾，系统都会自动加一个字符'\0'作为该字符串的“结束标志符”***，*系统据此判断字符串是否结束*
>
>   ```c
>   printf("%d",sizeof("123"));
>   //输出结果为4
>   ```
>
>   字符串常量中可以包括普通字符、*转义字符*和*通用字符*。
>
>   ![CleanShot 2022-09-09 at 15.24.33](/Users/wwt13/Documents/Notes/assets/CleanShot 2022-09-09 at 15.24.33.gif)
>
>   ⚠️**C中没有专门用于存储字符串的<u>数据类型</u>，只能通过字符指针和字符数组的形式进行存储**
>
>   *<font color="red">Attention:</font>'\0'是系统自动加上的，不是人为添加的*

### 常量定义方式

>   在 C 中，有两种简单的定义常量的方式：
>
>   1.  使用 **#define** 预处理器
>   2.  使用 **const** 关键字

```c
#define NUM 100;
int main(){
    const int num=100;
}
```

==二者区别==

1.   `#define`在预处理阶段展开，而`const`常量则在编译运行阶段使用（和普通变量一致）

2.   `#define`宏无类型，也不会做任何类型检查，`const`有具体类型，在编译阶段会执行类型检查

3.   `#define`的定义域为全局，而`const`的定义域为局部

     ```c
     void f1(){
         #define N 12;
         const int n 12;
     }
     void f2(){
         printf("%d",N);//正确
         printf("%d",n);//错误
     }
     ```

4.   `#define`在定义后可以通过`#undef`使宏定义失效（暂时不太清楚这个有什么用，因为宏定义的实效同样是全局失效）

因为`#define`只是简单的字符替换并且在预处理的时候就处理完毕，所以由于`#define`导致的bug是极难调试的，下面举一个常见的`#define`错误样例

```c
#define N 2+3
int main(){
    float i=N/2;
    printf("%f",i);//输出结果为3.5
}
```

*<font color="orange">Tip:</font>#define宏只用于定义非常简单的表达式*

#### const关键字详解

>   `const`是C中用于修饰变量的关键字，其实比起常量而言，const关键字更合适描述的是将变量转为只读`readonly`
>
>   *<font color="green">Ps:</font>经过const修饰的变量，必须在定义的时候进行初始化* 
>
>   *<font color="orange">Tip:</font>const关键字常用语限定函数的形参*
>
>   ```c
>   int func(const char *p){
>       //从p开始，先和*结合，代表p是一个指针，再和char结合，代表指针指向的内容是char类型的变量，再和const结合，代表该指针指向的char变量只读，不可修改
>   }
>   ```
>
>   同理，`const char *p`代表的就是指针指向不可变。

## 变量

>   任何语言中的变量含义都是一样的，它们都是对于程序可操作的存储空间的***名称***。*C语言中每个变量都有特定的类型*，而类型决定了变量所占据的**内存大小**和**布局**
>
>   ```c
>   type variable_list;
>   ```

变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头（c中的变量名是大小写敏感的）

```c
int i,j,k;//定义了三个int类型的变量
char c,cn;
float f;
double d;
```

>   不带初始化的定义：带有*静态存储持续时间*的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。
>
>   关于C变量初始化的更具体内容，参考<a href="/Users/wwt13/Documents/Notes/算法/C变量初始化.md">C变量初始化问题</a>

## 存储类

>   存储类是C/C++语言标准中，用于定义变量/函数的范围（scope）和生命周期（life time）的关键字，常见C中的存储类有`auto`,`register`,`static`,`extern`，该部分内容涉及很多方面的知识，具体细节还要等之后完整学习了操作系统等课程后再来进行完善。

### auto

>   所有局部变量默认的存储类

### register

>   该关键字请求编译器***尽可能的***将变量存储在CPU内部寄存器中，而不是通过内存寻址访问（非绝对存储）
>
>   “在许多机器上，register变量所产生的代码将比静态内存中的变量和堆栈中的变量所产生的代码执行速度更快。但是这取决于你的环境，***许多当前的编译器比程序员更加懂得怎样合理分配寄存器***。”[^《C与指针》]
>

如果一个程序逻辑中有很大的循环，该循环中有几个变量需要频繁的进行操作，那么这些变量可以使用register进行修饰（Maybe能加快运行速度）

并且一旦该变量被`register`关键字修饰（哪怕它没有被存储在CPU寄存器中），也无法对该变量进行取址操作`&`，因为寄存器无对于内存地址

![CleanShot 2022-09-14 at 13.31.36](/Users/wwt13/Documents/Notes/assets/CleanShot 2022-09-14 at 13.31.36.png)

同时，`register`变量必须是能被CPU所接受的类型，**这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度**。不过，有些机器的寄存器也能存放浮点数

只有*局部auto变量*和*形式参数*可以作为寄存器变量，因为每调用一个函数都会占用一些寄存器以存放变量，函数调用结束对应变量就会释放。

### static

>   `static`关键字对于局部变量和全局变量的作用不同。
>
>   -   局部变量：指示编译器在程序的生命周期内*保持局部变量的存在*，而不需要在每次它进入和离开作用域时进行创建和销毁
>   -   全局变量：使*变量的作用域限制在声明它的文件内*

### extern

>   `extern`关键字用于提供一个全局变量的引用，==全局变量对于所有的程序文件都是可见的！==有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用
>
>   因为需要引用其他文件的变量，所以需要将引用变量所在文件和被引用变量所在文件同时编译。

*<font color="green">Ps:</font>该关键字的使用需要修改`tasks.json`以进行多文件编译*

```json
//单文件编译
"${file}",
//包含extern的多文件编译
"${fileDirname}/*.c",
```

![CleanShot 2022-09-14 at 13.58.12](/Users/wwt13/Documents/Notes/assets/CleanShot 2022-09-14 at 13.58.12.gif)

## 动态内存管理

>   基本常用的就三个函数`malloc`,`calloc`,`free`，注意这三个函数都位于`stdlib`标准库中

-   `void *malloc(size_t size)`

    向系统申请分配连续可用的size字节的内存空间，并返回一个指向这块空间的void指针

    由于返回的指针类型是void类型，所以还需要进行*类型转换*才能进行使用

    使用malloc申请的堆内存需要程序员*手动释放*

-   `void *calloc(size_t nmemb,size_t size)`

    和malloc函数的区别在于calloc申请的内存空间会进行初始化，而malloc申请的空间内部均为随机值

    还有小区别就是参数不一样，参数1是空间块的个数，参数2则是空间块的大小

-   `void *free(void *ptr)`

    释放指针和对应内存的关系，ptr值不变但是指向内存变为非法

```c
int *ptr=(int*)malloc(10*sizeof(int));
memset(ptr,0,10*sizeof(int));
free(ptr);
int *ptr=(int*)calloc(10,sizeof(int));
free(ptr);
```



# Footnote

[^参考网页]:https://www.w3cschool.cn/c/c-intro.html
[^《C与指针》]: 该段内容引用自《C与指针》一书的151页

[^NOI基础语法]:http://noi.openjudge.cn/?message=%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F
