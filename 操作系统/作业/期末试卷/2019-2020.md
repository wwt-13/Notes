[toc]

# 2019-2020

## 存储管理 1

> 一个 32 位的虚拟存储系统有二级页表，其逻辑地址形式如下

-   逻辑地址
    |31 一级页表 22|21 二级页表 12|11 页内偏移 0|
-   物理地址
    |31 物理页框号 12|11 页内偏移 0|
-   页表项
    |31 物理页框号 12|11 标志位(0:有效位,0 代表 invalid,1 代表 valid 1:读写为,0 代表 Read Only,1 代表 Read/Write) 0|

1. 进程地址空间多少字节?
   32 位虚拟存储系统显然是$2^32$字节
2. 将答卷同学的学号最后两位作为 32 位逻辑地址的前两位，例如 183763MN 对应的逻辑地址为 0xMN000000。如果从逻辑地址 0xMN000000 开始映射 4MB 页表，第一级页表的逻辑地址在什么位置？第一级页表中有一个表项指向第一级页表，该表项的逻辑地址是多少？说明理由（注意 B 代表字节，一个 32 位地址占 4 字节）
   学号为 20373914，按照第一个页表项对应的第一个 4MB 页表，$PT_base+PT_base>>22<<2=PT_base+PT_base>>20$的页表项对应的就是$PT_base$开始的 4MB，那么这和 PD_base 又有什么关系呢？
   其实似乎不需要想的那么复杂，假设 va=0x140000000,按照页表访问的顺序走个流程就行，那么此时需要去$PD_base+va>>20=PDE_va$,再接下来只需要$PDE_va+va>>10=PTE_va$,然鹅 PTE_va=va

    似乎还是不够熟练，还是得推断一下

    只需要牢记一句话，第 n 个页表项映射的是地址空间中的第 n 个页表

    那么对于 PT_base 对应的页来说，映射它的页表项就是第 PT_base>>12 个页表项,又根据一级二级页表的映射关系可知，PD_base 的第一个页表项映射的就是 PT_base 对应的页表，所以可得$PD_base=PT_base+PT_base>>12<<2=PT_base+PT_base>>10$

    那么映射页目录的页表项又是哪一项呢？同理可得，$PDE_base=PD_base+PD_base>>12<<2=PD_base+PD_base>>10=PT_base+PT_base>>10+PT_base>>20$

    $PT_base=0x14000000$

3. 假设当前进程第一级页表的物理地址为 0x00200000，利用后面物理内存的信息，请在下表中写出以下指令的执行结果（对于 Load 指令，如果成功执行，写出读入的数据（读取一个字节），否则写 Error；对于 Store 指令，如果成功执行，写 OK，否则写 Error）

4. Load va=0x00001034
   PDE_va=PD_base+va>>20=0x00200000
   PDE_entry=00100007
   0111->Valid,Read/Write
   PTD_va=PDE_va+va>>10=00100000+1=00100004
   0000.0000.00|00.0000.0001
   PTD_entry=00002067
   0111->Valid,Read/Write
   pa=00002000+00000034=00002034

    取得内容为 0x12

## 存储管理 2

1. 一个进程的页面走向为：5、4、3、2、4、5、4、1、5、2、5、4、5、2、1，系统中共有 3 个物理内存页，开始时物理页中没有调入任何页面。使用最优页面置换算法、FIFO 页面置换算法和最近最久未使用算法（LRU）的缺页次数各为多少次？（给出计算过程）

最优页面置换算法(置换的是未来最长不会使用的页面)

| 1      | 2      | 3         | 4       | 5     | 6     | 7     | 8       | 9     | 10    | 11    | 12        | 13      | 14      | 15      |
| ------ | ------ | --------- | ------- | ----- | ----- | ----- | ------- | ----- | ----- | ----- | --------- | ------- | ------- | ------- |
| **5**  | **4**  | **3**     | **2**   | **4** | **5** | **4** | **1**   | **5** | **2** | **5** | **4**     | **5**   | **2**   | **1**   |
| _5_(6) | _4_(5) | _3_(null) | _2_(10) | 2(10) | 2(10) | 2(10) | 2(10)   | 2(10) | 2(10) | 2(14) | 2(14)     | 2(14)   | 2(14)   | _1_(15) |
|        | 5(6)   | 4(5)      | 4(5)    | 4(5)  | 4(7)  | 4(12) | _1_(15) | 1(15) | 1(15) | 1(15) | _4_(null) | 4(null) | 4(null) | 4(null) |
|        |        | 5(6)      | 5(6)    | 5(6)  | 5(6)  | 5(9)  | 5(9)    | 5(11) | 5(11) | 5(11) | 5(13)     | 5(13)   | 5(null) | 5(null) |

缺页次数为 7 次

FIFO 页面置换算法

| 1     | 2     | 3     | 4     | 5     | 6     | 7     | 8     | 9     | 10    | 11    | 12    | 13    | 14    | 15    |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| **5** | **4** | **3** | **2** | **4** | **5** | **4** | **1** | **5** | **2** | **5** | **4** | **5** | **2** | **1** |
| _5_   | _4_   | _3_   | _2_   | 2     | _5_   | _4_   | _1_   | 1     | _2_   | _5_   | _4_   | 4     | 4     | _1_   |
|       | 5     | 4     | 3     | 3     | 2     | 5     | 4     | 4     | 1     | 2     | 5     | 5     | 5     | 4     |
|       |       | 5     | 4     | 4     | 3     | 2     | 5     | 5     | 4     | 1     | 2     | 2     | 2     | 5     |

缺页次数为 11 次

LRU 算法

| 1     | 2     | 3     | 4     | 5     | 6     | 7     | 8     | 9     | 10    | 11    | 12    | 13    | 14    | 15    |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| **5** | **4** | **3** | **2** | **4** | **5** | **4** | **1** | **5** | **2** | **5** | **4** | **5** | **2** | **1** |
| _5_   | _4_   | _3_   | _2_   | 4     | _5_   | 4     | _1_   | 5     | _2_   | 5     | _4_   | 5     | 2     | _1_   |
|       | 5     | 4     | 3     | 2     | 4     | 5     | 4     | 1     | 5     | 2     | 5     | 4     | 5     | 2     |
|       |       | 5     | 4     | 3     | 2     | 2     | 5     | 4     | 1     | 1     | 2     | 2     | 4     | 5     |

缺页次数为 9 次

1. 假设只考虑页内碎片和页表引起的额外内存开销。如果进程的平均大小是 1MB，每个页表项的大小是 8B，为减小额外的内存开销，页面大小应设置为多少？（给出推导过程）

~假设页面大小为 xKB，则每个进程需要 1k\*k/xk=1k/x 页表项，大小为 1k/x\*8B=8kb/x~

给进程大小求最优页面大小，建议直接上公式

设进程平均大小为 s，页面大小为 p，页表项大小为 e，则分页开销为$\frac{s*e}{p}+\frac{p}{2}$

即页面大小为$\sqrt{2*s*e}$

## 存储管理

| 分区号 | 起始地址 | 分区大小 | 占用情况 |
| ------ | -------- | -------- | -------- |
| 1      | 0        | 10       | A        |
| 2      | 10       | 10       | free     |
| 3      | 20       | 12       | B        |
| 4      | 32       | 2        | free     |
| 5      | 34       | 6        | C        |
| 6      | 40       | 20       | free     |
| 7      | 60       | 24       | D        |
| 8      | 84       | 8        | E        |
| 9      | 92       | 18       | free     |
| 10     | 110      | 5        | F        |
| 11     | 115      | 13       | G        |

作业 X 请求 12KB 内存，作业 Y 请求 30KB 内存，作业 Z 请求 9KB 内存

X 到达、C 结束、D 结束、Y 到达、E 结束、Z 到达

FirstFit

| 起始地址 | 分区大小 | 占用情况 |
| -------- | -------- | -------- |
| 0        | 10       | A        |
| 10       | 9        | Z        |
| 19       | 1        | free     |
| 20       | 12       | B        |
| 32       | 8        | free     |
| 40       | 12       | X        |
| 52       | 30       | Y        |
| 82       | 28       | free     |
| 110      | 5        | F        |
| 115      | 13       | G        |

## 磁盘管理

2 6 10 20 22 38 40

20->22->38->40->10->6->2

30+48=78

78\*4=312ms

1 2 6 10 10 40 50

20--8ms->22--64ms->38--8ms->40->50->10->6->2->1

## 进程同步与互斥

典型的生产者-消费者问题

```c
mutex=Semaphore(1);
full_A=Semaphore(0);//缓冲区产品A数量
full_B=Semaphore(0);//缓冲区产品B数量
empty=Semphore(50);//缓冲区空闲位置

甲车间:
P(empty);
P(mutex);
produce_A();
V(mutex);
V(full_A);

乙车间:
P(empty);
P(mutex);
produce_B();
V(mutex);
V(full_B);

需要产品A的客户:
P(full_A)
P(mutex)
take_A();
V(mutex);
V(empty);

需要产品B的客户:
P(full_B)
P(mutex)
take_B();
V(mutex);
V(empty);
```

## 进程同步与互斥

```c
bus=Semphore(1);
wait=Semaphore(50);
mutex=Semaphore(1);
count=0;

巴士:
P(bus)
if(count>50){
    for(int i=0;i<50;i++){
        V(wait);
    }
    count-=50;
}
else{
    for(int i=0;i<count;i++){
        V(wait);
    }
    count=0;
}
V(bus)
depart();

乘客:
P(bus)
P(wait)
P(mutex)
count++;
V(mutex)
V(bus)
```

## 死锁

判断系统是否处于安全状态，只需要找到系统内的一条安全序列即可

- P1->0 4 4 0
- P4->0 6 7 2
- P5->0 6 8 6


处于死锁状态，

## 文件系统

2KB/4B=500个索引项

$10*2KB+1*500*2KB+1*500*500*2KB=20+1,000+500,000=501,020KB$

