# 第二次理论课作业

1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间?那种方法更好?
   这题题意看来好久才看懂，对于链表而言，其每个节点对应的页面大小为64KB，也就是说总共128MB/64KB=2M个节点
   对于位图而言，基础分配单位为n字节，也就是说总共128MB/nB=128M/n个位需要记录

   - 链表法分配：`(128MB/nB)/8=16M/n B`
   - 位图法分配：`(128MB/64KB)*(32+16+16)/8=16KB`

   也就是说，只要*n>1KB*,就存储空间而言，位图法在节省空间的效率上要远远好于链表法，反之则是位图法的空间效率更佳

2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、 9KB、12KB和15KB。对于连续的段请求:12KB、10KB、9KB。使用FirstFit、BestFit、 WorstFit和NextFit将找出哪些空闲区?

   - FirstFit: `20KB-10KB-18KB` 
   - BestFit: `12KB-10KB-9KB`
   - WorstFit: `20KB-18KB-15KB`
   - NextFit: `20KB-18KB-9KB`

3. 解释逻辑地址、物理地址、地址映射，并举例说明

   - 逻辑地址是指程序中使用的地址，它是由程序员定义的，与实际的内存地址无关。逻辑地址也称为虚拟地址。在程序执行时，**逻辑地址需要经过地址映射才能转换为实际的物理地址**。

   - 物理地址是指内存中实际的地址，它是**由硬件分配的**，与程序员无关。在程序执行时，逻辑地址会被映射为物理地址，程序才能访问内存中的数据。

   - 地址映射是指将逻辑地址转换为物理地址的过程。通常，地址映射是由操作系统的内存管理单元（MMU）来完成的。MMU会维护一个地址映射表，将逻辑地址映射为物理地址。在进行地址映射时，MMU会根据逻辑地址的页号和页内偏移量来查找地址映射表，找到对应的物理页号和物理页内偏移量，然后将它们组合成物理地址。

   举例来说，假设一个程序需要访问逻辑地址为0x1234的数据。假设该程序使用了分页机制，每个页的大小是4KB。那么，逻辑地址0x1234所在的页号为0x1，页内偏移量为0x234。程序会将逻辑地址0x1234发送给MMU进行地址映射。MMU会查找地址映射表，找到逻辑页号为0x1对应的物理页号为0x5，物理页内偏移量为0x234。然后，MMU会将这两个值组合成物理地址0x5234，程序就可以访问该地址的数据了。

   需要注意的是，地址映射表的维护是由操作系统负责的，因此程序无法直接访问物理地址。此外，地址映射表中的映射关系也是可变的，可以根据需要进行修改

4. 解释页式(段式)存储管理中为什么要设置页(段)表和快表，简述页式(段式)地址转换过程。

   - 在页式（段式）存储管理中，每个进程的地址空间通常被划分为多个页（段），每个页（段）的大小是固定的。为了将逻辑地址转换为物理地址，需要使用页表（段表）来记录每个页（段）的物理地址。由于页表（段表）通常比较大，访问它们的开销比较大，因此还需要使用快表来加速地址转换。

   - 页表（段表）是一种数据结构，用于记录每个页（段）的物理地址。通常，页表（段表）被组织成一个多级结构，以便支持大型地址空间。例如，在二级页表中，每个页表条目指向一个二级页表，每个二级页表中的页表条目指向一个物理页。页表（段表）中的每个页表条目通常包含了物理页的基地址和一些其他的控制信息。

   - 快表是一种高速缓存，用于加速地址转换。快表通常比页表（段表）小得多，因此访问它们的开销也比较小。快表中存储了最近访问的一些页表（段表）条目，以便在下一次访问时能够快速地找到对应的物理地址。

   *页式（段式）地址转换的过程如下*：

   1. 从逻辑地址中提取出页（段）号和页（段）内偏移量。
   2. 使用页（段）号在页表（段表）中查找对应的页表（段表）条目。
   3. 如果在快表中找到了对应的条目，则直接使用它的物理地址，否则需要在页表（段表）中查找对应的物理页（段）。
   4. 将物理页（段）的基地址和页（段）内偏移量组合成物理地址。

5. 叙述缺页中断的处理流程。

   当程序访问一个不在物理内存中的页时，会发生缺页中断。

   此时，操作系统会**将缺失的页从磁盘中读入内存**，**并更新页表中对应页表项的内容**。

   **如果该页的页表项已经在TLB中缓存了，那么操作系统还需要将这个页表项从TLB中清除**，以便`下一次`访问时能够重新从内存中读取最新的页表项（注意下一次访问到该va的时候才会触发*TLB_refill*）

6. 假设一个机器有38位的虚拟地址和32位的物理地址。

   1. 与一级页表相比，多级页表的主要优点是什么?
      - 节省了内存空间
      - 破除了页表项的空间连续性，实现了按需分配页表
   2. 如果使用二级页表，页面大小为16KB，每个页表项有4个字节。应该为虚拟地址中的第一级和第二级页表域各分配多少位?
      页面大小为16KB，所以页内偏移为14位，又因为页表项大小为4B，所以一页共4k个页表项，页框号为12位
      所以**第一级页表和二级页表域均分配12位，页内偏移14位**

7. 假设页面的访问存在一定的周期性循环，但周期之间会随机出一些页面的访问，如:0,1,2...,511,431,0,1,2...511,332,0,1,2,...,511等。请思考:

   1. LRU、FIFO和Clock算法的效果如何?
      `对于不符合局部性原理的访问。三种算法产生的缺页中断是一样的`。
   2. 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法?
      除了第500个页框，其他全部固定访问即可，每次出现页面置换的时候只要置换第500个页框就行

8. 一个交换系统通过紧缩技术来清理碎片。如果内存碎片和数据区域是随机分配的。而 且假设读写32位内存字需要10nsec. 那么如果紧缩128MB的内存需要多久?简单起见， 假设第0个字是碎片的一部分而最高位的字包含了有效的数据。
   由于碎片和数据是随机分布的，几乎整个内存都需要被拷贝，因为每个字都需要被读取和重写到不同的位置。读取 4 字节花费 10 nsec, 所以读取1个字节花费 2.5nsec。同理写一个字节也需要 2.5 nsec, 这样紧缩一个字节需要5 nsec. 所以，紧缩的速度是 200,000,000 bytes/sec。如果要复制 128 MB (𝟐^𝟐𝟕 字节= 1.34 * 𝟏𝟎^𝟖  字节), 计算机需要 𝟐^𝟐𝟕 /200,000,000 sec, 结果约为0.671 sec. 

